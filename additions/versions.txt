version 1.0.0:
доработанная версия из сети - ищет все датчики, а не только 2.
- исправлен алгортм поиска из сети в варианте записи кодов сразу в многострочный массив в ОЗУ в отличие от классического алгоритма из appnotes - через буферный однострочный массив
- индикация температур на жк-экран в одной строке, цифры чередуются по кольцу
- добавлена перекодировка русских символов

version 1.1.0:
- все текстовые строки и массив переведены во флэш

version 2.0.0:
- переработан алгоритм поиска на классический вариант через буферный однострочный массив, 
- запись кодов найденных устройств в массив структур в еепром
- в структуре в еепром предусмотрено место для записи имени датчика и диапазонов температур

version 2.1.0:
- индикация в две строки
- имя датчика по умолчанию формируется по шаблону с индексированием номера
- если больше 2-х, автоматически добавляется следующий экран
- автоматическое чередование экранов

version 3.0.0:
- код поиска датчиков выделен в отдельную функцию
- в режим поиска входим при нажатой кнопке на PORTB1 при рестарте 
- основная программа стартует прямо в режиме отображения по кодам, записанным в еепром
- количество устройств в епром пишется в последнюю ячейку 1024 (0х0400)
- если датчика нет, показания = -00

version 3.1.0:
- переработан вывод на дисплей - устранено мерцание и задержки вывода на экран при его обновлении
	-> для верхней и нижней строк дисплея созданы отдельные структуры
	-> сначала имя и температура записывается в структуру верхней или нижней строки, потом выводится на экран
	
version 3.2.0:
- проверка CRC8 выделена в отдельную функцию
- она принимает указатель на массив байтов, номер последнего байта с правильным значением CRC8* и номер устройства.
* - нужно для универсальности, поскольку проверять может быть нужно разное количество байт, например 9 для scrathpad или 8 для ID.

version 3.2.1:
- в случае несовпадения CRC в блоке проверки выводится сообщение по каждому датчику с ошибкой, "выводов" не делается, просто пока идём дальше по main

version 4.0.0:
- в структуру описания датчика добавлен параметр флага присутствия
- добавлена функция чтения блокнота для опроса присутствия при входе без первичной дешифрации адресов
- в блоке проверки CRC после первичной дешифрации введён счётчик датчиков, прошедших проверку, организован вывод на экран №№ датчиков с ошибкой и количества прошедших проверку по окончании 
- в блоке подготовки кадра добавлена возможность вывода знаков ? вместо цифр при сброшенном флаге присутствия датчика
- в блоке вывода на экран также добавлена возможность заменить знак +/- на знак ? при сброшенном флаге присутствия датчика
- при входе без первичной дешифрации добавлена проверка количества записанных датчиков в епром, если значение в последней ячейке епром =0, предлагается провести первичный поиск
- при входе без первичной дешифрации делается опрос присутствия путём чтения блокнота, проверки факта ответа, затем проверки CRC, сброс/установка флага присутствия и индикация № датчика при ошибках проверки CRC и отсутствии/присутствии датчика
- при входе с первичной дешифрацией последующий опрос присутствия путём чтения блокнота не производится, флаги устанавливаются при поиске и дешифрации
- добавлены сообщения для разных этапов для лучшей идентификации проблем
- упрощена передача кода в линию - убрали промежуточную переменную, в цикле используется напрямую buffer.code[i]
- добавлена проверка на максимально допустимое количество датчиков на линии при первичной дешифрации (не более 50)

version 4.1.0:
- убраны костыли формирования символов для дисплея:
	-- цифры формируются в main, а не в подготовке кадра 
	-- в подготовку кадра из main передаются сразу коды символов цифр и знака, либо коды символа ? при сброшенном флаге присутствия; 
- функция Disp_prep переименована в Frame
- temp_sign переведена из глобальных в main, в цикл опроса датчиков

version 4.2.0:
- активировано прерывание по переполнению счётчика timer0
- добавлен обработчик для опроса кнопки, определения длительности нажатия - длинный/короткий жим
- в бесконечный цикл в main вставлен тестовый блок переходов по факту нажатия кнопки, пока просто индикация на дисплее
- объявление и инициализация переменных бесконечного цикла измерения температур выенесена в инициализирующую часть main (почему они были в начале бесконечного цикла - хрен знает)
- устранена переменная dev_num в функции полной дешифрации устройств, поскольку она равна n-1, чтобы не путаться
- убран рудимент проверки n=0 при входе в цикл первичной дешифрации
- добавлена проверка ответа датчика в каждом цикле измерения (читаем байты блокнота 0...3, а не 0...1 ), чтобы видеть отваливание датчиков постоянно, а не только на перекличке при запуске
- код дешифрации 64 битов ID выделен из search_ID в в отдельную функцию find_ID, она будет использоваться независимо разными блоками при массовой или условной дешифрации :
 	-- на входе: указатель на буфер-строку data[8], указатель на New_conflict, указатель на last_conflict (они будут свои в каждой функции, вызывающей find_ID)
		-- внутри: bit, bit1, bit2, p - счётчик 64-х бит, j - счётчик байтов буфер-строки (они перешли в find_ID)
- запуск массовой дешифрации по нажатой кнопке при reset происходит только после её отпускания, чтобы успеть обнулить переменную press_time

version 5.0.0:
- добавлена функция замены-добавления устройств add_ID
- "забытый" кусочек стартового сброса и запроса присутствия перенесён из функций search_ID и add_ID в функцию find_ID	
- заход в функцию add_ID из main-while(1)-for() по длинному жиму
- при возврате счётчик for() обнуляется для возобновления индикации с начала
- для однозначности расположения устройства, за один заход заменяется/добавляется только одно с возвратом в main после каждого
	-- сначала проверяем количество уже записанных в епром
	-- затем ищем неактивные
	-- если неактивных нет и епром заполнена, возврат с сообщением
	-- если неактивных нет, а место в епром есть, опцию замены не предлагаем, сразу в блок добавления
	-- если неактивные есть, а епром заполнена, попытка добавить закончится выходом в main
	-- короткий жим - отказ, идём дальше
	-- длинный жим - подтверждение
	-- добавлены сообщения для управления и контроля хода процесса

version 5.1.0:
- в структуре device переменнная flags заменена на битовое поле flags типа bit_set
	-- определено 4 нижних бита: флаги присутствия, выхода за нижний или верхний пределы температур, пропадание в процессе измерений (нужность обдумывается)
	-- резервные 4 верхних бита
- по тексту кода buffer.flags заменена на бит buffer.flags.active там, где работаем с этим битом; копирование/чтение buffer.flags в/из епром осталось без изменений
- убраны cli() и sei() из ISR(TIMER0_OVF_vect) за излишностью
- в сообщении "Всего устройств" не отображаются десятки, если их 0, цифра выводится в центре нижней строки.
- в сообщениях об ошибках CRC или чтения блокнота теперь выводим имя устройства, а не его порядковый номер
- в блоке define для OW и для кнопки переопределена битовая маска через номер пина, а не через абсолютное значение
- в блоке полной дешифрации в сообщениях о количестве найденных и прошедших проверку устройств теперь можно выводить двузначное число

version 5.2.0:
- добавлен блок удаления устройств в add_ID
- после удаления остальные ниже по списку сдвигаются вверх на одну строку
- изменен способ формирования порядкового номера устройства в имени по умолчанию в add_ID, иначе после удаления этот номер генерится некорректно:
	-- в предпоследней ячейке епром хранится значение последнего присвоенного номера
	-- в имя по умолчанию вставляется это значение + 1, после чего значение в епром инкрементируется
	-- номер устройства в имени теперь не имеет ограничения по количеству цифр
- после возврата в main обновляется n, а i=0.
- изменен алгоритм очистки экрана при индикации температур, она теперь делается в Frame, из Display удалено (иначе при смене кадра остаются рудименты имён предыдущего при неравной длине имён устройств)

version 5.3.0:
- введены комплексные функции работы с дисплеем, работают через простейшие функции
	-- функции вывода на экран принимают координаты символа и строки (нумерация от 0)
	-- функция очистки экрана

version 5.4.0:
- при возврате из add_ID после удаления всех устройств принудительно возвращает обратно пока не добавить хотя бы одно
- при входе в main без проведения первичной дешифрации при n==0 в епром принудительно отправляет в add_ID и крутит пока не добавить хотя бы одно устройство
- в меню корректировки пропускаются разделы удаления и замены, если n==0
- в add_ID в блоке сравнения найденного ID с записанными изменено:
	-- цикл for(i=0;i<n;i++) заменён на do-while(i<n), иначе при n==0 в него не попасть, т.к. i==n==0 сразу.
	-- при несовпадении найденного с записанными к условию i==(n-1) добавлено условие || (i==n) для случая n==0, иначе эта проверка при n==0 не работает

version 5.5.0:
- унифицировано преобразование числа в строку через функцию utoa_fast_div на основе быстрого деления на 10 сдвигами и сложениями
	-- принимает число и указатель на массив для кодов символов цифр этого числа
	-- добавлен #define N_DIGS 5 для определения размера массива для кодов символов цифр, т.к. он свой у каждой вызывающей функции
	-- в последний элемент массива ставит завершающий 0, дальше коды символов цифр от последней к первой
	-- возвращает указатель на первую значащую цифру преобразуемого цисла
	-- нюанс: при добавлении номера в имя по умолчанию приходится передавать указатель на &dev_name [(sizeof dev_name) - N_DIGS ], чтобы завершающий 0 встал на последний элемент массива dev_name
- запрещён вывод ведущего нуля в температуре, кроме одного - перед десятичной точкой

version 5.6.0:
- устранён потенциальный баг при добавлении номера в стартовое имя из-за передачи указателя как &dev_name [(sizeof dev_name) - N_DIGS ], поскольку sizeof dev_name адекватно работает только при char == 1 байт.
	-- сначала номер конвертируется стандартным путём в массив digits
	-- после этого последние три элемента digits (две цифры и завершающий 0) копируются в dev_name
- размер массива стартового имени задаётся в define N_NAME
	-- соответственно все счётчики	копирования имени работают с этим параметром, вместо абсолютного размера
	-- размер поля имени в структуре может быть изменём одним движением
	-- размер самой структуры описания устройства теперь также можно изменить одним движением
- добавлен define EEP_MEM размера епром
	-- константы адресов последней и предпоследней ячеек епром теперь меняются автоматически при изменении EEP_MEM
	-- максимальное количество устройств в епром теперь также меняется автоматически при изменении EEP_MEM
	
version 5.7.0:
- в блоке преобразования целой и десятичной частей температуры все операции умножения	заменены на сдвиги и сложения, размер бинарника упал на 1кб !!(из-за этого temp_int теперь uint16_t)
- delay_ms(2000) на индикацию заменён на цикл ожидания накопления счётчика прерываний до 2с, опрос кнопки перенесён внутрь него, теперь реагирует на нажатие сразу
* фича - после возврата из add_ID при удалении или добавлении сначала показывается хвост ранее отправленного на индикацию

version 5.7.1:
- активировано прерывание по приходу данных в UDR0
- написан обработчик прерывания по приходу данных в UDR0 - запись в кольцевой буфер
- написан кольцевой буфер для приёма данных из UART
- временно размер кольцевого буфера задан 256 байт, чтобы индексы самосбрасывались при переходе через 255, т.е. пока не применяем маску обнуления.
- при приходе строки в кольцевой буфер она выводится на lcd в цикле паузы для индикации

version 5.7.2:
- в цикл паузы для индикации добавлен блок распознавания команды переименования датчика и её выполнения

version 5.7.3:
- активировано прерывание по приходу данных в UDR0
- написан обработчик прерывания по приходу данных в UDR0 - запись в кольцевой буфер
- написан кольцевой буфер для приёма данных из UART (отправка по uart пока предполагается без кольцевого буфера, напрямую через загрузку в UDR0)
- временно размер кольцевого буфера задан 256 байт, чтобы индексы самосбрасывались при переходе через 255, т.е. пока не применяем маску обнуления.
- при приходе строки в кольцевой буфер она выводится на lcd
- добавлена функция преобразования строки цифр в число с учётом знака, нужно для записи в описание датчика пределов температур, полученных по uart
- после получения температуры из датчика и разделения на целую и дробную части добавлена переменная для хранения целой части с учётом знака для сравнения с tmin/tmax, для отриц.числа перевод в дополнитльный код
- добавлены блоки установки флагов по фактам пересечения температурой установленных пределов и однократной отправки сообщения об этом (пока на lcd, дальше это будет использовано для отправки смс) 
 	-- учтена необходимостнь однократной отправки только при первом пересечении предела
	-- дальше запрет, пока не вернётся в пределы и снова не выйдет за
- написаны блоки сброса флагов при возврате температуры в установленные пределы
- в цикл паузы для индикации добавлены блоки распознавания команд и выполнения:
 -- проверка и чтение принятого в кольцевой буфер
 -- переименование датчика: REN_Sens.01_Sensor1
 -- запись верхнего и нижнего пределов температур в описание датчика: TLAL(илиTHAL)_Sens.01_-(+)20
 -- установка и сброс для каждого датчика флага необходимости отправки смс при пересечении температурой установленных пределов SMS_TL1(0)(илиTH1(0))_Sens.01
- отдельно написан блок индикации уровня сигнала морганием штатным светодиодом ардуины, но пока не добавлен в обработчик перывания TIMER0_OVF

version 5.7.4:
- в обработчик перывания TIMER0_OVF добавлен блок индикации уровня сигнала морганием штатным светодиодом ардуины, прицеплен на PORTB5
- добавлены подтверждения выполнения команд изменения пределов температур и активации sms-извещений
- добавлена обработка пропадания датчика в процессе опроса в цикле
 -- установка/сброс флага пропадания в процессе опроса в цикле
 -- однократное информирование пользователя
 -- повтор только после появления датчика и нового пропадания

version 5.7.5:
- введён массив хранения целой части последних измеренных температур с учётом знака для последующей отправки на SMS-запрос
- добавлены функции отправки символа, массива и строки из флэш по USART по аналогии с таковыми для lcd
- в тестовом режиме отправляет в терминал сообщения о пропадании датчика в основном цикле
- в тестовом режиме отвечает на запрос всех температур - выводит в столбик со знаком

version 5.7.6:
- в обработчике прерывания приёмки данных по USART включена обработка ошибки приёма байта (ошибка кадра) и переполнения буфера, пока выводит сообщение на lcd и в терминал.
- в ответ на запрос всех температур выводит в столбик имя датчика и температуру со знаком
- перевод каретки и строки выделены в функцию, чтобы не забивать код лишними 4-мя байтами каждый раз.
- в имена функций и переменных кольцевого буфера добавлено RX_, чтобы в дальнейшем создать кольцевой буфер для отправки с префиксом TX_.
- массив для приёма данных из кольца переназван в msg[], а то tmp[] как-то мусорно

version 5.7.7:
- добавлено маскирование индексов, чтобы потом можно было сделать кольцо другого размера
- расчёт количества байт в кольце сделан в одну строку; немного необычно, но это работает, понятный вариант оставлен в комментариях ниже
- обработка ошибки кадра перенесена - до чтения из UDR во временную переменную, как должно быть по DataSheet.

version 5.7.8:
- добавлен кольцевой буфер на отправку по USART
- написан обработчик прерывания по факту опустошения UDR0 передатчика; грузит байты в UDR0 из кольцевого буфера, пока не опустошит его, потом запрещает себя и стоит, пока кто-то не разрешит его работу снаружи
 -- прерывание активируется в в main после формирования посылки в кольцнвом буфере
 -- выключается в обработчике по факту опустошения кольцевого буфера
- добавлены функции отправки байта, массива, строки из флэш и пары CRLF через кольцевой буфер
- ответ на запрос температур переведён на работу через кольцевой буфер

version 5.7.9:
- пробую формировать текст смс через конкатенацию частей для дальнейшего использования в обработчике отправки смс через вызов функции перелива теста смс в кольцевой буфер отправки.
- сделана отправка объединённой строки строки при аварии на линии.

**! в начале цикла поиска устройств в add_ID потенциально лишний кусок проверки превышения лимита епром, поскольку это делается перед циклом поиска и выбрасывает в main, если нет неактивных устройств

version 6.0.0:
в главном цикле меню и индикация переведены на режим конечных автоматов, блок работы по UART пока удалён
Начало main прежнее, изменение только в части принудительной активации КА меню перед главным циклом если n==0, опрос датчиков блокируется (раньше был вызов Add_ID():
1. Если кнопка нажата при запуске:
 - делаем полный поиск устройств на шине и перезапись найденного в епром
 - srch_done = 1 - пропускаем начальный опрос линии
2. Если кнопка не нажата при запуске, т.е. полной дешифрации не было, обновляем и проверяем n: 
 - если n==0 
	> активируем КА меню в цикле 
	> деактивируем КА опроса датчиков и вывода на lcd
	> пропускаем начальный опрос линии (srch_done = 1);
 - если n!=0 и srch_done == 0 делаем начальный опрос линии;
3. переходим к циклу:
	1) опрос датчиков (отключается при переходе в меню):
	> запрос температур, их анализ, запись байта значений в массив
	> КА обновления полей в структуре вывода на экран и вывод на экран
		>>> (Frame()) пишет в структуру кадра очередные строки (2 или 1, если она последняя или единственная), если (Display()) отправил предыдущий кадр на lcd, а в текущем проходе опрашиваются ожидаемые по очереди
		>>> по окончании паузы на индикацию следующие две строки выводятся на lcd (Display()) и разрешается запись в кадр следующих по порядку строк (Frame()), когда до них доходит очередь опроса.
	2) КА меню замены/добавления/удаления - остановка опроса датчиков и индикации температур, остальное работает.

version 6.1.0:
добавлен модуль SIM900, в N_RESET добавлено gsm_lvl=0, чтобы не моргал диод на время перезапуска модема; разбор команд пока только "reqest-answer",
Начало main прежнее:
1. Если кнопка нажата при запуске:
 - делаем полный поиск устройств на шине и перезапись найденного в епром
 - srch_done = 1 - пропускаем начальный опрос линии
2. Если кнопка не нажата при запуске, т.е. полной дешифрации не было, обновляем и проверяем n: 
 - если n==0 
	> активируем КА меню в цикле 
	> деактивируем КА опроса датчиков и вывода на lcd
	> пропускаем начальный опрос линии (srch_done = 1);
 - если n!=0 и srch_done == 0 делаем начальный опрос линии;
3. переходим к циклу:
	1) Опрос датчиков
	- опрос
	- КА вывода на lcd
	2) КА меню (Опрос датчиков деактивирован до выхода из меню)
	3) Проверка кольцевого буфера и выгрузка в msg
	4) КА СИМ900
	- режим (ре-)старта
	- обычный режим 

version 6.1.1:
Изменена отправка смс: изменён способ формирования смс для отправки - в задачу записваем не текст, а тип смс и параметры, а хэндлер сразу шлёт нужные строки из флэш в TX_ring 
	- добавлен enum для названий шаблонов смс
	- создан тип структура sms_struct:
	> номер шаблона смс (определяет, какие строки из флэш и в каком порядке брать, какие параметры и куда в текст добавить)
	> номер устройства
	> параметры для добавления в текст	смс 
	- создана глобальная переменная sms_buff типа sms_struct для временной записи параметров смс
	- из основного кода наполняем её в соответствии с событием
	- постановщик задачи на отправку смс вызывается с передачей указателя на неё
	- постановщик задачи записывает в локальную переменную задачи отправки смс sms_struct sms_txt одержимое sms_buff
	- при старте хэндлера тест смс формируется и отправляется на лету в кольцо отправки TX_ring
		> короткие смс отправляются в кольцо целиком
 	> длинный текст	типа ответа на T_ALL	передаётся в TX_ring частями по одной строке с разрешением на отправку в модем после каждой строки
 	> для начала при передаче длинной смс не выходим из хэндлера, ждём конца передачи каждой строки до полной передачи текста в модем
по короткому нажатию отправка смс по шаблону TEST1 - QUICK
по приему request отправка	смс по шаблону TEST2 - SLOW

version 6.1.2:
- добавлен глобальный указатель t_all для обращения к локальному массиву last_t, иначе в to_do не поставить задачу отправки всех температур, не достать до last_t
- в начале main определяем t_all = last_t
- по короткому нажатию	ставится задача отправки всех температур и оставлен вывод QUICK на lcd
- в to_do при приёме T ALL ставится задача отправки всех температур

version 6.1.3:
- отправка длинных строк в TX_ring сделана без поллинга падения флага UDRIE0 (по сравнению с ds18b20_6.1.1).

version 6.1.4:
реализован основной функционал смс-команд
REN <имя> <новое имя> - переименование
THAL <имя> <знак><температура> - верхний порог температуры
TLAL <имя> <знак><температура> - нижний порог температуры
SMS TL1(0) <имя> - смс при понижени ниже нижнего порога, 1 - вкл, 0 - выкл
SMS TH1(0) <имя> - смс при повышении выше верхнего порога, 1 - вкл, 0 - выкл

version 6.1.5:
- добавил запись '\r\nOK\r\n' в конец RX_ring при переполнении, чтобы чужие длинные смс не зацикливали хэндлер чтения из-за отсутствия ОК после текста
- добавлен запрос баланса:
	> в парсер добавлен массив money[6] для цифр суммы баланса; static, чтобы можно было передать на него указатель в задачу отправки смс
	> в структуру шаблона смс добавлен указатель на uint8_t для указателя на массив цифр баланса, см. выше
	> отправляем смс BALANCE
	> функция to_do обнаруживает в msg слово BALANCE	и ставит в очередь задачу отправки команды ussd-запроса баланса
	> в парсер добавлен блок поиска \r\n+CUSD:_; если есть, массив money набивается из msg цифрами до десятичного знака с учетом возможного первого "-" и ставится задача отправки смс
	> в хэндлере отправки смс цифры баланса берутся по указателю на массив money - так можно, т.к. в него пишется только баланс, а актуальным является только последнее значение
- относительно ds18b20_6.1.4 строка out_to_queue (&sms_buff) перенесена из последней строки to_do() в каждый блок декодирования команд, т.к. при постановке задачи отправки команд не ставится задача отправки смс

version 6.1.6:
- уходим от жёстко заданных номеров телефонов - создаём в озу глобальную структуру с массивами, в них телефоны при запуске будут копироваться из сим-карты; пока символы заданы жёстко, из флэш строки удалены
- в хэндлере отправки команды добавлена конкатенация по указателю на массив в озу, т.к. телефоны будут в оперативке (это дальше будет нужно при отправке команд работы с записной книжкой в сим-карте, возможно прибавится ещё параметр):
	> хэндлер теперь принимает три указателя - на строку команды из флэш, массив параметра из озу, строку параметра из флэш
	> для конкатенации массива в озу используем strcat, а не strcat_P
- в to_do при проверке телефона в тексте смс указатель на массив во флэш заменён на указатель в озу, причина та же.
- в хэндлере отправки смс указатель на строку с телефоном во флэш заменён на указатель на массив в озу, причина та же.
- добавляем отправку уровня сигнала в смс:
	> создан массив [31] во флэш с цифровыми процентными значениями уровня сигнала, чтобы не пересчитывать x*100/31 каждый раз, быстрее выбрать из списка
	> создана глобальная переменная для грязного уровня сигнала 0...31 из ответа модема на запрос, она используется как индекс для выборки из массива значений (см.выше)
	> в блок отправки всех температур добавлена строка с уровнем сигнала
	> для разделения строк в смс вместо \r\n оказалось нужным использовать просто \n, телефон интерпретирует как \r\n, иначе перенос строки не происходит

version 6.1.7:
- в хэндлере отправки команд теперь 4 параметра - указатель на команду из флэш, указатель на массив-строку в озу и два указателя на строки во флэш, нужно для работы с сим-картой

version 6.1.8:
- отправка команд тепрь нанапрямую в TX-Ring, без промежуточной сборки во временном буферном массиве

version 6.1.9:
- поиск текста смс в ответе модема теперь через отсчёт шестой кавычки, а не заданием смещения от начала строки ответа (жёсткое смещеини может работать не корректно при наличии телефона отправителя в сим)

version 6.2.0:
пока без изменений 6.1.8 - 6.1.9, добавлю после отладки, - включаем рабту с сим-картой
- телефоны пользователей и баланса хранятся в сим-карте и оттуда копируются в озу при загрузке
- увеличены TODO_MAX (25), TX_RING_SIZE (64) и cmd_txt(50) в send_cmd, иначе не влезают длинные команды работы с записной книгой сим (36 символов в CPBW). cmd_txt уйдёт, не критично
- добавляем авторизацию пользователей - админ и обычный пользователь, с ограничением прав; пока только двое, можно добавлять
	> длина имени пользователя и баланса жёстко 6 символов (balans, user_0, useer_1... - пока ограничение
	> в начале работы при чистой сим-карте (в озу тоже нули) первая смс считается от админа, обрабатывется в парсере - телефон админа из системной части ответа модема отправляется в сим и в массив
	> дальше проверка на админ-пользователь происходит в парсере, где проверяется номер отправителя, после смс либо передаётся в to_do, либо нет
	> в to_do уже только обрабатывается смс, проверка прав не производится
	
- перед установкой сим карта очищается
+ при загрузке второй (после AT+CMGD=1,4) ставим задачу получить код баланса из сим 
	>+ при получении кода пишем три цифры в резервный массив, оттуда три цифры переносим в рабочий (с # перед и после кода) (в парсере)
	>+ если не пришёл, вопрос откладывается до выполнения задачи запроса получения оператора сети
+ при загрузке третьей ставим задачу получить оператора сети AT+COPS?
	>+ при удачной идентификации оператора записываем в массив номеров соответствующий код ussd-запроса баланса (в парсере)
	>+ при неудаче смотрим в массив, возможно предыдущая задача туда вписала код (в парсере)
		>>+ если в массиве нули, запрашиваем админа о необходимости прислать цифры баланса (парсер)
+ при загрузке четвёртой ставим задачу получить телефон из сим по имени user_0
	>+ если в ответе пришёл номер в формате +79ххххххххх, записываем его в структуру соответсвенно имени и ставим задачи чтения по именам user_1, user_2, ..., их просто копируем в структуру (парсер)
	>+ если в ответе только ОК или неверный формат, ничего не записываем, в массиве нули (в парсере)
+ в хэндлере отправки смс проверяем правильность формата телефона из поля структуры, если там нули, сбрасываем задачу
+ при получении смс "user_0 +79ххххххххх" сверяем телефон отправителя с записанным в структуре в поле user_0. (в to_do)
	>+ если в массиве пусто (или неверный формат номера) записываем номер отправителя в поле user_0, ставим задачу записать его на сим в ячейку 2 с именем user_0 и отправляем подтверждение
	>+ если телефон отправителя совпадает с номером в массиве, (пере)записываем в массив телефон из текста смс и ставим задачу записи в сим в ячейку 2 с именем user_0 вместо текущего (смена админа)
	>+ при несовпадении номера отправителя с номером user_0, игнорируем, ничего не шлём отправителю
+ при получении смс "user_1...3 +79ххххххххх" сверяем телефон отправителя с записанным в поле user_0 (в to_do)
	>+ если совпадает, записываем номер из текста в массивы user_1...3, ставим задачу записать их на сим в ячейки 3...5 с именами user_1 ... user_3 и отправляем подтверждение отправителю
	>+ если не совпадает, игнорируем, ничего не шлём отправителю
+ при получении смс "users" (в to_do)
	>+ при совпадении номера отправителя с номером user_0, ставим задачу отправки перечня номеров
	>+ при несовпадении ничего не шлём
+ при получении смс "BALANCE #xxx#" при совпадении номера отправителя с user_0 записываем в основное и резервное поля структуры этот код баланса и ставим задачу записи трёх цифр из резервного поля на сим под именем balance 
+ при получении смс "DELETE +79ххххххххх при совпадении номера отправителя с user_0 удаляем указанный в тексте смс номер из массивов, если он есть хотя бы в одном, и шлём этот номер (с нулями) в сим

version 6.2.1:
применены изменения из 6.1.8 и 6.1.9
- удалены промежуточные буферы формирования команд перед отправкой их в TX-Ring
- снято ограничение на длину имени абонента в записной книжке сим (см.6.1.9)

version 6.2.2:
- работать с записной книжкой сим только по имени абонента, без указания номера ячейки, очень неудобно - клонируются записи; для добавления номера ячейки в группу команд AT+CPBx увеличиваем список аргументов send_cmd
	> [AT+CPBx=]
	> [№ ячейки,"]
	> [номер телефона]
	> [",145,"]
	> [user_x]
	> ["]

version 6.2.3:
- USER_0 заменён на ADMIN
- исправлена ошибка позиционирования указателя в блоке первой регистрации админа (строка 1574  - 1579)
- в массиве телефона админа перед первой регистрацией не должно быть + вначале

version 6.2.4:
- в блоке первой регистрации админа (строка 1574  - 1590) заменена установка указателя - вместо жёсткого смещения на 23 ищем третьи кавычки

version 6.2.5:
  добавляем авторизацию и права доступа пользователей
- в ISR(USART_RX_vect) при ошибке кадра добавлено чтение буфера без записи в кольцо, иначе флаг FE (frame error) в UCSR0A не сбросится.
- добавлен user_2 в массив телефонов и строка во флэш
- добавленj phones.ans_to для фиксации юзера, запросившего баланс
- добавлены ABNT_1 и ABNT_2 в enum для лучшей читаемости идентификаторов юзеров
- в структуру шаблона смс добавляется поле access
- в битовом поле устройства sms_T переименовано в sms_T_0, вместо relay_1 и relay_2 теперь sms_T_1, и sms_T_2, вместо reserved - relay, для флагов разрешения смс юзерам по событиям
- в парсере при приёме текста смс отправитель фиксируется в переменной who и заносится в sms_buff.access (надо ли плодить переменные, мложет обойтись только sms_buff.access?)
- при постановке задачи на отправку смс в задачу копируется значение sms_buff.person
- при отправке смс в команду передаётся телефон согласно значения sms_buff.person, т.е. отправка идёт строго по адресу запроса
- в to_do для определения прав доступа используется sms_buff.person
	>* если в to_do попали в блок BALANCE, значение sms_buff.person дополнительно фиксируется в phones.ans_to, по ней определяем запросившего баланс в парсере при получении +CUSD (см.ниже)*
	>* при получении +CUSD в парсере для постановки задачи отправки смс с балансом принудетельно указываем, кому отправить ответ: sms_buff.person = phones.ans_to (см.выше)*
- в to_do в зависимости от значения access производятся или не производятся действия:
	> если производятся, отправляется обычное подтверждение запросившему
	> если запрешено, отправляется смс "access denied" на телефон отправителя команды (см.ниже) 
- реализовано в:
	> при переходе порогов температур шлём тем, для кого установлен флаг, в каждом блоке проверки температур добавлено sms_buff.person =...
	> T ALL - шлётся отправителю, доступ общий
	> REN <имя> <новое имя> - доступ только у админа, ему подтверждаем, остальным "access denied"
	> THAL <имя> <знак><температура> - верхний порог температуры - изменение только админ
	> TLAL <имя> <знак><температура> - нижний порог температуры - только админ
	> SMS TL1(0) <имя> - смс при понижении ниже нижнего порога, 1 - вкл, 0 - выкл - можно всем, отправка смс всем
	> SMS TH1(0) <имя> - смс при повышении выше верхнего порога, 1 - вкл, 0 - выкл  - можно всем, отправка смс всем
	> BALANCE #xxx# - доступ к изменению кода у админа, баланс шлётся всем
	> DELETE <+79xxтелефон> - удаление юзера, только админ
	> USER_(0...1) <+79ххтелефон) - замена админа, добавление юзера - только админ
	> USERS - список юзеров, только админ

* при получении смс с запросом баланса приходится в to_do дополнительно фиксировать запросившего, поскольку есть разрыв между смс с запросом и смс запросившему из-за промежуточной задачи USSD-запроса
* если этого не сделать, то, при поступлении новой смс в промежутке между смс с запросом баланса и смс с ответом, в sms_buff.person окажется неверный адрес запросившего баланс.
	>> Получили смс
	>> штатно зафиксировали отправителя в sms_buff.person
	>> передали текст смс в to_do
	>> если в в to_do попали в блок BALANCE, дополнительно фиксируем запросившего в phones.ans_to
	>> ставим задачу USSD-запроса
	>> в парсере нашли +CUSD
	>> принудительно поместили в sms_buff.person значение phones.ans_to
	>> дальше штатно отправляем смс

ToDo:

вариант 1 - обработку событий организовать через таблицу :предположительно 10 вариантов событий, т.е. массив [10][4], строка соответствует событию:
> выгода - любое количество событий
> недостаток - дополнительный расход памяти на таблицу событий
 1. событие (реле, смс по абонентам) - один байт идентификатора uint8_t, определить через enum
 2. датчик - один байт номера устройства uint8_t
 3. температура - один байт int8_t
 4. направление прохода границы - вверх или вниз - определить через enum uint8_t
- гистерезис задать переменной, единой для всех событий, в таблицу не записывать
- в описании устройства в битовом поле предусмотреть флаг наличия события по каждому устройству
- таблицу хранить в eeprom, при загрузке записывать в озу

Вариант 2 - обработку событий организовать через конфигурационную переменную устройства
> выгода - не занимаем память таблицой событий
> недостаток - ограниченный объём записей в устройстве или увеличивать размер конфигурационной переменной устройства
 1. в термодатчиках уже есть пороги температур, флаги перехода уровней, флаги-защёлки по событиям, в т.ч. отправки смс
 2. в ключах предусмотреть поля (предварительно):
	>> № термодатчика	
	>> лимит температуры
	>> направление прохода
	>> флаг состояния
	>> флаг внешней команды действия

- КА записи в епром - запись в епром, остановка опроса датчиков и индикации температур на период записи в епром ???
- подумать, не сделать ли глобальной переменную количества устройств, пока глобальность решается путём чтения из епром
