#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h> //для sei() и cli()
#include <stdlib.h> // для abort()
#include <avr/pgmspace.h> //раскомментировать, если хранить строки и массив во флэш
#include <avr/eeprom.h> //для работы с еепром
#include <string.h> //для strncpy
// #include <math.h> раскомментировать, если нужна ф-я modf в ф-ии преобразования ЧПТ в цифры для передачи в ЖКИ

//блок define для LCD
#define RS PORTD3 //  Номер вывода порта, по которому передаётся команда RS в ЖКИ
#define EN PORTD2 //  Номер вывода порта, по которому передаётся команда EN в ЖКИ
#define LCD_COM_PORT PORTD // Порт для посыла команд в ЖКИ (команды и данные - могут быть не на одном порту!!!)
//#define LCD_COM_PORT_DDR DDRD // Регистр направления данных в порту, куда подцеплены линии команд ЖКИ, см.выше
#define LCD_DAT_PORT PORTD // Порт отправки данных (и команд в данном случае)в ЖКИ
#define LCD_DAT_PORT_DDR DDRD // Регистр направления данных порта, куда подцеплен ЖКИ линиями данных (и команд в данном случае)
/* бит-маски выделения ниблов и отправки их в порт LCD_DAT_PORT составляются соответственно номеров выводов, к которым
подключен ЖКИ. в данном случае используются выводы 4-7 порта. */

//блок define для OW
#define DDR_OW_PORT DDRB // Регистр направления данных порта, к одному из выводов которого подключена линия 1-Wire
#define OW_PORT PORTB // Порт, к одному из выводов которого подключена линия 1-Wire
#define OW_PIN PINB // Регистр приёма ответа линии 1-Wire, к одному из выводов которого подключена эта линия
#define OW_PIN_NUM 0 // Номер PIN, к которому подключена линия 1-Wire, для макроса _BV()
#define bit_msk 0x01 // Битовая маска для проверки сигнала от линии 1-Wire на соответствующем пине

//блок define для кнопки
#define SRC_PORT PORTB //Порт, к одному из выводов которого подключена кнопка нового поиска (здесь порт один с OW line)
#define DDR_SRC_PORT DDRB // Регистр направления данных порта, к одному из выводов которого подключена кнопка нового поиска (здесь порт один с OW line)
#define SRC_PIN PINB // Регистр приёма состояния кнопки
#define SRC_PIN_NUM 1 // Номер PIN, к которому подключена кнопка, для макроса _BV()
#define src_msk 0x02 // Битовая маска для проверки сигнала от линии 1-Wire на соответствующем пине

// блок текстовых сообщений во флэш
unsigned char absence[] PROGMEM = "Нет датчиков"; //ошибка на этапе первой инициализации датчиков перед входом в алгоритм дешифрации адресов
unsigned char no_answer[] PROGMEM = "Нет ответа датч."; //ошибка на старте дешифрации адресов после чтения первых двух тайм-слотов
unsigned char present_n[] PROGMEM = "Подкл.дат. "; //количество датчиков, опознанных при первичной дешифрации адресов
unsigned char dev_excess[] PROGMEM = "Много датчиков"; //ошибка в процессе первичной дешифрации адресов, если количество датчиков превысит 50
unsigned char error[] PROGMEM = "Ошибка иниц."; //ошибка на этапе проверки CRC после первичной дешифрации адресов, выводится № датчика,
unsigned char init_n[] PROGMEM = "Иниц.дат. "; //количество датчиков, прошедших проверку CRC после первичной дешифрации адресов
unsigned char init_srch[] PROGMEM = "Выполните поиск"; // ошибка при отсутствии в епром данных датчиков, если не проводилась первичная дешифрация адресов
unsigned char scratch_err[] PROGMEM = "Ошибка блокн. "; //ошибка при проверке CRC данных, прочитанных из блокнота, выводится № датчика
unsigned char no_answer_n[] PROGMEM = "Нет ответа "; //ошибка на этапе чтения чтения блокнота при перекличке в main - если датчик не ответил, то конф.байт == FF, выводится № датчика
unsigned char ow_check[] PROGMEM = "Опрос линии";

// блок глобальных переменных и структур

typedef struct //структура для параметров устройства
{
    unsigned char name[8]; // имя 1W устройства
    unsigned char code[8]; // код 1W устройства
    char tmax; // максимальная Т
    char tmin; // минимальная Т
    char flags;// флаги состояния
} device; // структура для параметров 1W устройства

device buffer; // переменная для обмена озу <-> епром
device ee_arr [2] EEMEM; // oбъявляем массив структур в епром, 2 - пока временно, для начала
unsigned char *location; //переменная для имени 1W устройств - задаётся юзером вместо имени по умолчанию
unsigned char dev_num = 0x00; //переменная порядкового номера для добавления к имени 1W устройств по умолчанию, отличается от счётчика n в функции поиска только (dev_num - 1) == n, можно без неё.
unsigned char dev_name[8] = {'D', 'x', 'x', 'x', 'x', 'x', 'x', 'x'}; //"Dxxxxxx" - имя устройства по умолчанию, к нему добавится ASCII код порядкового номера
const uint16_t dev_qty = 0x3FF;//константа, содержащая значение адреса последней ячейки в епром для переменной количества дешифрованных устройств
uint8_t scratchpad [9]; //массив байтов, прочитанных из блокнота DS18B20

typedef struct // структура для строки дисплея, из них строится кадр (экран)
{
    uint8_t name[8]; //имя устройства
    unsigned int dig_1;//первая цифра температуры
    unsigned int dig_2;//вторая цифра температуры
    unsigned int dig_3;//десятичная цифра температуры
    unsigned char sign; //знак температуры
} line;
line line_up; // верхняя строка кадра
line line_dn; // нижняя строка кадра

// Функция записи команды в ЖКИ
void lcd_com(unsigned char p)
{
    LCD_COM_PORT &= ~(1 << RS); // RS = 0 (запись команд)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p & 0xF0); // Выделяем старший нибл
    LCD_COM_PORT |= (1 << EN);  // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)

    LCD_COM_PORT &= ~(1 << RS); // RS = 0 (запись команд)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p << 4); // Выделяем младший нибл
    LCD_COM_PORT |= (1 << EN); // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)
    _delay_us(50);
}

// Функция записи данных в ЖКИ, выводит символы на lcd
void lcd_dat(unsigned char p)
{
    LCD_COM_PORT |= (1 << RS); // RS = 1 (запись данных)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p & 0xF0); // Выделяем старший нибл
    LCD_COM_PORT |= (1 << EN); // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)

    LCD_COM_PORT |= (1 << RS); // RS = 1 (запись данных)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p << 4); // Выделяем младший нибл
    LCD_COM_PORT |= (1 << EN); // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)
    _delay_us(50);
}

//Таблица перекодировки в русские символы.
static const unsigned char convert_HD44780[64]PROGMEM =
        {
                0x41,0xA0,0x42,0xA1,0xE0,0x45,0xA3,0xA4,
                0xA5,0xA6,0x4B,0xA7,0x4D,0x48,0x4F,0xA8,
                0x50,0x43,0x54,0xA9,0xAA,0x58,0xE1,0xAB,
                0xAC,0xE2,0xAD,0xAE,0xAD,0xAF,0xB0,0xB1,
                0x61,0xB2,0xB3,0xB4,0xE3,0x65,0xB6,0xB7,
                0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0x6F,0xBE,
                0x70,0x63,0xBF,0x79,0xE4,0x78,0xE5,0xC0,
                0xC1,0xE6,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7
        };

// функция перекодировки символов
static unsigned char lcd_rus(uint8_t c)
{
    if  (c > 191)
    {
        c -= 192;
        c = pgm_read_byte (&(convert_HD44780[c]));
    }
    return c;
}

// функция вывода строки на ЖКИ
void send_string_to_LCD (const unsigned char *s)
{
    while(pgm_read_byte (s))
    {
        lcd_dat(lcd_rus(pgm_read_byte(s++)));
        _delay_ms (1);
    }
}

// функция вывода массива символов на ЖКИ (в массиве должен быть символ "конца строки" 0x00)
void send_arr_to_LCD (unsigned char *s)
{
    while(*s)
    {
        lcd_dat(lcd_rus (*s++));
        _delay_ms (1);
    }
}

// Функция инициализации ЖКИ
void lcd_init(void)
{
    // Активизация четырехразрядного режима
    lcd_com(0x28); // 4 бит режим 2 строки, 5х8
    lcd_com(0x08); //выключение экрана, выключение отображения курсора, курсор не мигает 0000 1000(bin)
    lcd_com(0x06); //инкрементирование, сдвиг всего экрана отключен 0000 0110(bin)
    lcd_com(0x01); // очистка дисплея
    _delay_us(3000);// время выполнения очистки не менее 1.5ms
    lcd_com(0x0C); //включение экрана 0000 1100(bin)
    //lcd_com(0x80); // Будем выводить строку в 1-ю верхнюю левую позицию 1 строки экрана
}

// функция выводит знаки на LCD, вызывается из Frame
void Display (uint8_t line_qty)
{
    if (!line_qty) //если строка только одна (верхняя) - чистим дисплей, но выводим первую строку в любом случае
    {
        lcd_com(0x01); // очистка дисплея
        _delay_us(1500);// время выполнения очистки не менее 1.5ms
    }
    lcd_com(0x80); // выводим имя в 1-ю верхнюю левую позицию 1 строки экрана
    send_arr_to_LCD (line_up.name); //выводим имя устройства
    lcd_com(0x88); // выводим температуру в 8-ю (от 0) позицию 1 строки экрана
    lcd_dat(line_up.sign);
    lcd_dat(line_up.dig_1);
    lcd_dat(line_up.dig_2);
    lcd_dat('.');
    lcd_dat(line_up.dig_3);

    if (line_qty)	//выводим вторую строку, если она есть
    {
        lcd_com(0xC0); // выводим строку в 1-ю верхнюю левую позицию 2 строки экрана
        send_arr_to_LCD (line_dn.name); //выводим имя устройства
        lcd_com(0xC8); // выводим температуру в 8-ю (от 0) позицию 2 строки экрана
        lcd_dat(line_dn.sign);
        lcd_dat(line_dn.dig_1);
        lcd_dat(line_dn.dig_2);
        lcd_dat('.');
        lcd_dat(line_dn.dig_3);
    }
}

// Функция подготовки кадра (вызывается из main):
// выделяет цифры из трехзначного числа Number,
// распределяет вывод целого и десятичного заначения по символам,
// заполняет массив строк для индикации на LCD
void Frame (uint8_t Dig1, uint8_t Dig2, uint8_t Dig3, uint8_t sign, uint8_t i, uint8_t n)
//определяем строку LCD: i это № устр-в: 0,2,4... верхняя, 1,3,5... нижняя
{
    uint8_t j=0;
    if (!(i & 0x01))
    {
        while (j < 8)
        {
            line_up.name[j] = buffer.name[j];
            j++;
        }
        line_up.dig_1 = Dig1;
        line_up.dig_2 = Dig2;
        line_up.dig_3 = Dig3;
        line_up.sign = sign;

        if (!(i & 0x01) && (i==(n-1))) //если строка верхняя, но последняя, сразу вывод на LCD
        {
            Display (0); // передаём в функцию вывода кол-во строк кадра: 0->1 строка, 1->2 строки
        }
    }
    else
    {
        while (j < 8)
        {
            line_dn.name[j] = buffer.name[j];
            j++;
        }
        line_dn.dig_1 = Dig1;
        line_dn.dig_2 = Dig2;
        line_dn.dig_3 = Dig3;
        line_dn.sign = sign;

        Display (1);// передаём в функцию вывода кол-во строк кадра: 0->1 строка, 1->2 строки
    }
}


// Функция инициализации датчиков
unsigned char init_device(void)
{
    unsigned char OK_Flag = 0; // переменная результата опроса присутствия датчиков
    // unsigned char Flag = 0;
    cli();
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(480);//задержка 480 мкс
    //«отпускает линию»
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(70);//задержка 70 мкс ,берем чуть больше после перепада
    if (!(OW_PIN & bit_msk)) // проверяем факт ответа датчиков, если PINB==0 - ответ есть
        OK_Flag = 1; // если ответ есть
    else
        OK_Flag = 0; // если ответа нет
    _delay_us(410);//остальная задержка 410 для окончания импульса присутствия
    sei();// разрешаем прерывания
    return OK_Flag;
}
// функция отправки 1 в линию
void send_1 (void)
{
    cli(); //Запретим общие прерывания
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(6);//задержка 15 мкс
    //«отпускает»
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(64);//задержка 45 мкс ,берем чуть больше
    sei();// разрешаем прерывания
}
// функция отправки 0 в линию
void send_0(void)
{
    cli(); //Запретим общие прерывания
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(60);//задержка 120 мкс
    //«отпускает»
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(10);//задержка 1 мкс ,перед записью следующего бита
    sei();// разрешаем прерывания
}

//Функция выдачи команд на датчики
void send_command (unsigned char command)
{
    unsigned char i;
    for (i=0; i < 8; i++)
    {
        if (command & 0x01) // если позиция бита 1, то передаем 1
        {
            send_1 ();
        }
        else //передаем 0
        {

            send_0 ();
        }
        command >>= 1;//сдвигаем вправо для обработки следующего бита
    }
}

//Функция чтения из датчиков
unsigned char read_data(void)
{
    unsigned char bit;
    cli(); //Запретим общие прерывания
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(6);//задержка 2 мкс
    //«отпускает», управление передается датчику
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(9);//задержка 9 мкс ,перед считыванием
    bit = (OW_PIN & bit_msk);
    _delay_us(55);//задержка 50 мкс ,перед чтением следующего бита
    sei();// разрешаем прерывания
    return bit;
}

// Проверка CRC8
int8_t CRC_check(uint8_t *data, uint8_t crcbitN)
{
    uint8_t j; // счётчик байтов в массиве data, котоый проверяем
    uint8_t crc8 = 0; //переменная для сравнивания результата расчёта CRC8 по младшим (crcbitN-1) байтам с CRC8 из crcbitN байта
    uint8_t data_crc; // сюда в начале цикла сдвигов пишем каждый очередной байт из полученного из main массива
    uint8_t u; //счётчик битов при сдвигах в алгоритме расчёта CRC8
    for(j = 0; j < crcbitN; j++)
    {
        unsigned char bit_crc; //локальная переменная
        data_crc = data[j];
        for (u = 0 ; u < 8; u++)
        {
            bit_crc = ((crc8 ^ data_crc) & 0x01);
            if (bit_crc == 0)
                crc8 >>= 1;
            else
            {
                crc8 ^= 0x18;//  11000 , по модулю т.е. там где 0 и 1 будут 1
                crc8 >>= 1; //сдвгаем влево
                crc8 |= 0x80;//+ 1000 0000
            }
            data_crc >>=1;
        }
    }
    if (crc8 == data[j]) // если последний байт и CRC равны - хорошо
        return 0;
    else
        return 1;
}
// Функция поиска устройств, запись в еепром
void search_ID(void)
{
    unsigned char i, j = 0;// переменные счетчики
    unsigned char n = 0;  //количество датчиков, записанных в епром, она же переменная одного входа в цикл поиска всех датчиков
    unsigned char m = 0; //количество датчиков, прошедших проверку CRC8
    unsigned char data [8];// буфер-массив для хранения кодов датчиков

    sei();// либо SREG |= (1 << 7); разрешить общее прерыввание
    if (n == 0)
    {
        unsigned char p = 1;  //переменная для цикла считыввания кода
        unsigned char bit = 0x01;// начальная позиция бита
        unsigned char New_conflict = 0; //переменная для новой позиции бита конфликта
        unsigned char last_conflict = 0;  //переменная для старой позиции бита конфликта

        for (j = 0; j < 8; j++) //обнулим буфер-массив
        {
            data[j] = 0x00;
        }
        j = 0;//обнуляем счётчик буфер-массива
        unsigned char bit1, bit2; //для сравнения битов двух тайм слотов

        do
        {
            New_conflict = 0;
            n++;
            if (n > 50) //если число устройств превысило 50, не влезет в епром
            {
                lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
                send_string_to_LCD (dev_excess);//выводим "много датчиков"
                abort ();
            }

            if (!init_device())	// выдаём импульс сброса и проверяем ответ датчиков
            {
                // если ф-ция сброса вернёт 0
                lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
                send_string_to_LCD (absence);//выводим "нет датчиков"
                abort ();
            }
            send_command(0xF0); // команда поиска
            // сигнал сброса и команду поиска необходимо подавать для каждого датчика

            while (p <= 64) // пока не будут прочитаны все 64 бита
            {
                bit1 = read_data();//первый тайм-слот
                // _delay_us(2); // без этой задержки иногда не работает
                bit2 = read_data();//второй тайм-слот
                if (bit1 && bit2) // сравниваем полученные биты , если обе единицы
                {
                    lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
                    send_string_to_LCD (no_answer);//выводим "нет ответа датч."
                    abort ();
                }
                else if ((bit1) && (!bit2))// бит = 1
                    data[j] |= bit;//записываем бит
                else if((!bit1) && (bit2))// бит = 0
                    data[j] &= ~bit;
                else if((!bit1) && (!bit2))//Конфликт оба 0
                {
                    //здесь будем сравнивать позиции битов,  в номерах которых произошли конфликты  в переменной N_conflict
                    if (p == last_conflict)//если текущая позиция бита в котром произошел конфликт ==  позиции в предыдущем исчеслении (скорей всего 0-ая позиция), то запишем в адресс 1
                        data[j] |= bit;
                    else if (p > last_conflict)// если номер позиции больше, номера предыдущего опроса, то запишем 0 и номер позиции конфликта обновим
                    {
                        data[j] &= ~bit;
                        New_conflict = p;
                    }
                        //если вдруг текущий номер позиции меньше, номера позиции предыдущего исчесления(Если вдруг текущий бит, при конфликте, при очередном исчеслении не дошел еще до номера
                        //конфликта предыдущего исчесления,  содержит 0 , то это будет считаться новым конфликтом)
                    else if (!(data[j] & bit))
                    {
                        New_conflict = p;
                        data[j] &= ~bit;
                    }
                    else
                    {data[j] |= bit;}
                }

                // Далее запишем соответствующий бит, который при следующем исчеслении включит соответствующие устройства
                if(data[j] & bit)
                {
                    send_1 ();
                }
                else //передаем 0
                {
                    send_0 ();
                }

                p++;//увеличиваем на 1
                bit <<= 1;//сдвигаем влево

                if (!bit) //сдвиг проходит все 8 бит и значение равно 0
                {
                    j++;
                    _delay_ms(100);
                    bit = 0x01;
                }

            }//выходит из цикла после обработки 64-х битов
            last_conflict = New_conflict;
            p = 1;

            location = dev_name;//временно локации устройства присваивается ASCII код имени по умолчанию
            utoa (dev_num, (void*)&dev_name[3], 10);// в имя по умолчанию добавляется ASCII код номера устройства по порядку поиска
            //приходится использовать явное приведение к void*, т.к. utoa и strncpy не жрут ничего, кроме char*, а у нас unsigned char*
            strncpy((void*)buffer.name, (void*)location, sizeof buffer.name); // записываем ASCII код имени в поле name буфера

            // запись ID-кода 1-го 1W устройства в ID_string и копирование его в буфер-структуру
            for (j=0; j < 8; j++)
            {
                buffer.code[j] = data[j];
            }
            /* заполняем поля tmax, tmin и flags буфера значениями */
            buffer.tmax = 30;
            buffer.tmin = 6;
            buffer.flags = 1; // датчик активен
            eeprom_update_block (&buffer, &ee_arr[dev_num], sizeof(buffer)); // записываем в епром описание текущего 1W устройства.
            dev_num ++; //инкременируем номер устройства - это будет следующее

            if (last_conflict != 0)
            {
                j = 0;
                bit = 0x01;
            }
        }

        while (last_conflict != 0); // пока номер бита конфликта не равен 0, если равен то все датчики найдены

        lcd_com(0x01); // очистка дисплея
        _delay_us(1500);// время выполнения очистки не менее 1.5ms
        lcd_com(0x80);
        send_string_to_LCD (present_n); // Выводим "Подкл.дат."
        lcd_dat(n +'0');// выводим количество найденых датчиков (значение переменной n из цикла поиска)
        _delay_ms(3000);
    }

    //Датчики найдены, адреса записаны, необходимо проверить правильность переданной информации
    i = 0;//обнулим, начнем проверрку с 0-х индексов
    j = 0;
    m = n; //начальное значение колич. датчиков для счётчика прошедших проверку CRC
    while(i != n)//обрабатываем количество устройств(равно n из цикла поиска), начинаем с первого устройства
    {
        eeprom_read_block (&buffer, &ee_arr[i], sizeof(buffer));// считываем описание усройства из епром
        if (CRC_check (buffer.code, 0x07)) // передаём указатель на массив с ID, номер байта CRC8; если вернётся 1, CRC не ОК
        {
            m--;
            buffer.flags = 0x00; //сброс флага присутствия
            lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
            send_string_to_LCD (error);//выводим "ошибка иниц."
            lcd_dat (i +'0');
            _delay_ms(2000);
        }
        i++;
    }

    lcd_com(0x01); // очистка дисплея
    _delay_us(1500);// время выполнения очистки не менее 1.5ms
    lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
    send_string_to_LCD (init_n); //выводим "Иниц.дат."
    lcd_dat(m +'0');//выводим кол-во найденных устр-в, прошедших проверку CRC8
    _delay_ms(3000);
    lcd_com(0x01); // очистка дисплея
    _delay_us(1500);// время выполнения очистки не менее 1.5ms
    //lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
    //send_string_to_LCD (tempC); //выводим "Темп-ра "
    //eeprom_update_byte (&dev_qty, n);0x0400
    eeprom_update_byte ((uint8_t*)dev_qty, n);
}

/*// Функция выводит на LCD побитно байты 2, 3, 4 конф.регистра
void Disp_pad (void)
{
	lcd_com(0x01); // очистка дисплея
	_delay_us(1500);// время выполнения очистки не менее 1.5ms
	uint8_t j;
	uint8_t bit;
	for (j=2; j<5; j++)
	{
		switch (j)
		{
			case 2 : lcd_com(0x80);
			break;
			case 3 : lcd_com(0xC0);
			break;
			case 4 : lcd_com(0x88);
			break;
		}

		for (bit=0x80; bit !=0;)
		{
			if (scratchpad[j] & bit)
				lcd_dat('1');
			else
				lcd_dat('0');
			bit = bit >> 1;
		}
	}
}	*/
// функция чтения блокнота датчика
uint8_t scratchpad_rd (void)
{
    uint8_t j = 0;// счетчик байт блокнота
    uint8_t p;  //счётчик 72 битов для цикла считывания  блокнота
    uint8_t bit = 0x01;// начальная позиция бита для формирования байта блокнота
    uint8_t bit_reg; // сюда вносим ресультат чтения очередного бита
    //uint8_t data_byte; // переменная для временного хранения одного байта ID-кода

    for (j = 0; j < 9; j++) //обнулим массив
    {
        scratchpad[j] = 0x00;
    }
    j = 0;//обнуляем счетчик
    init_device(); // выдаём импульс сброса и проверяем ответ датчиков
    send_command(0x55);//команда соответствия
    // передаём код устройства к которому обращаемся
    for (j = 0; j < 8 ; j++)
    {
        //data_byte = buffer.code[j];
        //send_command (data_byte); //передаем побайтово код устройства
        send_command (buffer.code[j]);
    }
    j = 0;//обнуляем счетчик
    send_command(0xBE); // читаем блокнот
    for (p = 1; p <= 72; p++) // пока не будут прочитаны все 72 бита
    {
        bit_reg = read_data(); //читаем бит
        if (bit_reg)
            scratchpad[j] |= bit; //записываем бит =1
        else
            scratchpad[j] &= ~bit; // записываем бит = 0
        bit <<= 1;//сдвигаем влево
        if (!bit) //сдвиг проходит все 8 бит и значение равно 0
        {
            j++;
            _delay_ms(100);
            bit = 0x01;
        }
    }//выходит из цикла после обработки 72-х битов
    init_device();
    //Disp_pad ();
    //_delay_ms(2000);
    if (scratchpad[4] == 0xFF) // датчик не ответил, все биты конф.байта == 1
        return 1;
    else if (CRC_check(scratchpad, 0x08))//если CRC не OK
        return 2;
    else
        return 0;
}



//начало основой программы
int main(void)
{
    uint8_t n = 0; // для количества записанных в епром устройств
    uint8_t srch_done = 0; // признак проведённой первичной дешифрации

    // LCD_COM_PORT_DDR |= (1<<RS)|(1<<EN); //линии RS и EN выходы, раскомм. если DAT и COM цеплять на разные порты
    // LCD_COM_PORT = 0x00; // ставим 0 в RS и EN, раскомментировать если цеплять на разные порты
    LCD_DAT_PORT_DDR = 0xFF; // порт данных (и команд в данном случае) ЖКИ - на выход
    LCD_DAT_PORT = 0x00;// ставим 0 в порт данных и команд ЖКИ
    _delay_ms(200); // Ожидание готовности ЖКИ
    lcd_init(); // Инициализация дисплея

    DDR_SRC_PORT &= ~_BV(SRC_PIN_NUM);//ставим 0 - пин кнопки активирован на вход
    SRC_PORT |= _BV(SRC_PIN_NUM);//ставим 1 - внутр. подтяжка к +
    if (!(SRC_PIN & src_msk)) //если на пине 0, т.е кнопка нажата, делаем полный поиск устройств на шине и перезапись найденного в епром
    {
        search_ID();
        srch_done = 1;
    }
    if (!srch_done) // если дешифрация не выполнялась, переходим к опросу ранее записанных и далее к измерениям
    {
        n = eeprom_read_byte((uint8_t*)dev_qty); //считываем из епром число записанных в епром усройств
        if (!n) // если n==0, поиск не производился, в епром пусто или мусор
        {
            lcd_com(0x01); // очистка дисплея
            _delay_us(1500);// время выполнения очистки не менее 1.5ms
            send_string_to_LCD (init_srch);// выводим "Выполните поиск"
            abort ();
        }

        lcd_com(0x01); // очистка дисплея
        _delay_us(1500);// время выполнения очистки не менее 1.5ms
        lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
        send_string_to_LCD (ow_check);// сообщение "опрос линии"

        for (uint8_t i = 0; i< n; i++) //начинаем перекличку с первого датчика (от 0)
        {
            eeprom_read_block (&buffer, &ee_arr[i], sizeof(buffer)); // считываем описание усройства из епром
            uint8_t pad_res = scratchpad_rd(); // результат чтения блокнота
            if (!pad_res)
            {
                buffer.flags = 0x01;// подъём флага присутствия
            }
            else if (pad_res == 1)//если датчик просто не ответил, конф.байт будет == FF
            {
                buffer.flags = 0x00; //сброс флага присутствия
                lcd_com(0x01); // очистка дисплея
                _delay_us(1500);// время выполнения очистки не менее 1.5ms
                lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
                send_string_to_LCD (no_answer_n);
                lcd_dat(i +'0'); //выводим № не ответившего датчика
                _delay_ms(2000);
                lcd_com(0x01); // очистка дисплея
                _delay_us(1500);// время выполнения очистки не менее 1.5ms
            }
            else if (pad_res == 2) //читаем блокнот i-го датч., если CRC не ОК, выводим сообщение об ошибке
            {
                buffer.flags = 0x00; //сброс флага присутствия
                lcd_com(0x01); // очистка дисплея
                _delay_us(1500);// время выполнения очистки не менее 1.5ms
                lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
                send_string_to_LCD (scratch_err);
                lcd_dat(i +'0');
                _delay_ms(2000);
                lcd_com(0x01); // очистка дисплея
                _delay_us(1500);// время выполнения очистки не менее 1.5ms
            }
            eeprom_update_block (&buffer, &ee_arr[i], sizeof(buffer)); // возвращаем в епром описание текущего 1W устройства с обновлённым байтом флагов.
        }
        lcd_com(0x01); // очистка дисплея
        _delay_us(1500);// время выполнения очистки не менее 1.5ms
    }

    while(1)
    {
        unsigned char i, j, n = 0;// переменные счетчики
        unsigned char temperature[2];	// массив байтов температуры LB и HB
        unsigned char temp_int; //целая часть температура
        unsigned char temp_float; // дробная часть температуры
        unsigned int temp; // временная переменная для перевода из дополнительного кода в прямой при "-" температуре
        unsigned char temp_sign; // признак знака температуры
        uint16_t Number = 0; //сюда попадёт значение температуры
        uint8_t Num1, Num2, Num3 = 0;//переменные для цифр температуры
        uint8_t Dig_1, Dig_2, Dig_3, sign = 0;//переменные для кодов символов цифр температуры и символа знака

        n = eeprom_read_byte((uint8_t*)dev_qty); //читаем количество датчиков, записанных в епром
        for (i = 0; i< n; i++) //начинаем опрос с первого датчика (от 0)
        {
            eeprom_read_block (&buffer, &ee_arr[i], sizeof(buffer)); // считываем описание усройства из епром
            if (buffer.flags)//если флаг присутствия поднят, запрашиваем температуру
            {
                init_device();//импульс сброса и присутствие
                send_command(0x55);//команда соответствия
                // после передадим код устройства к которому обращаемся
                for (j = 0; j < 8 ; j++)
                {
                    //unsigned char data_byte; // переменная для передачи кода
                    //data_byte = buffer.code[j];
                    //send_command (data_byte); //передаем побайтово код устройства
                    send_command (buffer.code[j]);
                }

                send_command (0x44);//команда преобразования
                while (!read_data()) ;// выполняется цикл пока на линии не установится 1 - преобразование закончено
                init_device();//импульс сброса и присутствие
                send_command(0x55);//команда соответствия
                for (j = 0; j < 8 ; j++)   // опять передаем адресс устройства, к которому будем обращаться
                {
                    //unsigned char data_byte; // переменная для передачи кода
                    //data_byte = buffer.code[j];
                    //send_command (data_byte); //передаем побайтово код устройства
                    send_command (buffer.code[j]);
                }
                send_command (0xBE);//команда чтение памяти
                for (j = 0; j < 2; j++) //считываем первые два байта температуры
                {
                    unsigned char i;//локальная переменная для внутреннего цикла
                    unsigned char data_temp = 0x00;
                    for (i = 0; i < 8; i++)
                    {
                        data_temp >>= 1;
                        if (read_data()) //если 1, то устанавливаем  старший бит 1
                            data_temp |= 0x80;
                    }
                    temperature[j] = data_temp;
                }
                init_device();	// сброс датчиков для прекращения передачи данных
                // преобразуем полученное в значение температуры
                if ((temperature[1]&0b10000000) == 0) // проверка на отрицательность температуры
                    temp_sign =0; //рисуем плюс на ЖКИ
                else //переводим из доп.кода в прямой
                {
                    temp = ((unsigned int)temperature[1]<<8) | temperature[0];
                    temp = ~temp + 1;
                    temperature[0] = temp;
                    temperature[1] = temp>>8;
                    temp_sign = 1;  //рисуем минус на ЖКИ
                }

                temp_int = ((temperature[1]&0b00000111)<<4)|(temperature[0]>>4);	//выводим  целое знач. температуры
                temp_float = (temperature[0]&0b00001111); //выделяем с помощью битовой маски дробную часть
                /*
                преобразуем в целое число и *10 (нужен только 1 десятичный знак),
                десятичную "." будем ставить принудительно
                1. temp_float = temp_float * 0.0625 -  просто умножаем на 0.0625 или
                     (temp_float >> 4)  - делим на 16 сдвигами
                2. (temp_float + temp_int)*10 - просто умножаем на 10 или
                    ((((temp_float + temp_int)<<1) + (temp_float + temp_int)<<3)) - умножаем на 10 сдвигами
                */
                Number = ((uint16_t)((temp_float*0.0625 + temp_int)*10));//Явно приводим к uint8_t, чтобы уйти от float;
                //преобразуем число в цифры, потом их в коды символов цифр
                Num1 = Num2 = Num3 = Dig_1 = Dig_2 = Dig_3 = 0;
                while (Number >= 100)
                {
                    Number -= 100;
                    Num1++;
                }
                while (Number >= 10)
                {
                    Number -= 10;
                    Num2++;
                }
                Num3 = Number;
                Dig_1 = Num1 + '0';
                Dig_2 = Num2 + '0';
                Dig_3 = Num3 + '0';
                switch (temp_sign)
                {
                    case 0 : sign = '+';
                        break;
                    case 1 : sign = '-';
                        break;
                }
            }
            else  //если флаг присутствия сброшен, на дисплей шлём ???.?
            {
                Dig_1 = '?';
                Dig_2 = '?';
                Dig_3 = '?';
                sign = '?';
            }
            Frame (Dig_1, Dig_2, Dig_3, sign, i, n);  //передаём коды символов цифр и  знака, № устр-ва для определ.№ строки диспл., кол-во строк
            if ((i & 0x01)||(i == (n-1))) //определяем строку вывода на дисплей: № устр-в 0,2,4... верхняя, 1,3,5... нижняя;
                //если строка нижняя - ставим задержку перед сменой экрана.
                //Если строка верхняя, но устройство последнее - тоже задержка для считывания экрана
            {
                _delay_ms(2000);
            }
            temp_int = 0;
            temp_float = 0;
        }
    }	// закрывающая скобка бесконечного цикла
}      // закрывающая скобка основной программы
