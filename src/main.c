#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdlib.h> // для abort()
#include <avr/pgmspace.h> //раскомментировать, если хранить строки и массив во флэш
// #include <math.h> раскомментировать, если нужна ф-я modf в ф-ии преобразования ЧПТ в цифры для передачи в ЖКИ

#define RS PORTD3 //  Номер вывода порта, по которому передаётся команда RS в ЖКИ
#define EN PORTD2 //  Номер вывода порта, по которому передаётся команда EN в ЖКИ
#define LCD_COM_PORT PORTD // Порт для посыла команд в ЖКИ (команды и данные - могут быть не на одном порту!!!)
//#define LCD_COM_PORT_DDR DDRD // Регистр направления данных в порту, куда подцеплены линии команд ЖКИ, см.выше
#define LCD_DAT_PORT PORTD // Порт отправки данных (и команд в данном случае)в ЖКИ
#define LCD_DAT_PORT_DDR DDRD // Регистр направления данных порта, куда подцеплен ЖКИ линиями данных (и команд в данном случае)
/* бит-маски выделения ниблов и отправки их в порт LCD_DAT_PORT составляются соответственно номеров выводов, к которым
подключен ЖКИ. в данном случае используются выводы 4-7 порта. */
#define DDR_OW_PORT DDRB // Регистр направления данных порта, к одному из выводов которого подключена линия 1-Wire
#define OW_PORT PORTB // Порт, к одному из выводов которого подключена линия 1-Wire
#define OW_PIN PINB // Регистр приёма ответа линии 1-Wire, к одному из выводов которого подключена эта линия
#define OW_PIN_NUM 0 // Номер PIN, к которому подключена линия 1-Wire, для макроса _BV()
#define bit_msk 0x01 // Битовая маска для проверки сигнала от линии 1-Wire на соответствующем пине
#define D 2 //максимальное количество датчиков, которое может быть подключено.

const unsigned char tempC[] PROGMEM = "Темп-ра ";
const unsigned char absence[] PROGMEM = "Нет датчиков";
const unsigned char error[] PROGMEM = "ошибка иниц.";
const unsigned char present_n[] PROGMEM = "Подкл.дат. ";
const unsigned char init_n[] PROGMEM = "Иниц.дат. ";
const unsigned char no_answer[] PROGMEM = "Нет ответа датч. ";
//char buffer [20];
unsigned char temp_sign; // признак знака температуры для ф-ции вывода на ЖКИ


//Таблица перекодировки в русские символы.
static const unsigned char convert_HD44780[64]PROGMEM =
        {
                0x41,0xA0,0x42,0xA1,0xE0,0x45,0xA3,0xA4,
                0xA5,0xA6,0x4B,0xA7,0x4D,0x48,0x4F,0xA8,
                0x50,0x43,0x54,0xA9,0xAA,0x58,0xE1,0xAB,
                0xAC,0xE2,0xAD,0xAE,0xAD,0xAF,0xB0,0xB1,
                0x61,0xB2,0xB3,0xB4,0xE3,0x65,0xB6,0xB7,
                0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0x6F,0xBE,
                0x70,0x63,0xBF,0x79,0xE4,0x78,0xE5,0xC0,
                0xC1,0xE6,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7
        };
// функция перекодировки символов
static uint8_t lcd_rus(uint8_t c)
{
    if  (c > 191)
    {
        c -= 192;
        c = pgm_read_byte (&(convert_HD44780[c]));
    }
    return c;
}

// Функция записи команды в ЖКИ
void lcd_com(unsigned char p)
{
    LCD_COM_PORT &= ~(1 << RS); // RS = 0 (запись команд)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p & 0xF0); // Выделяем старший нибл
    LCD_COM_PORT |= (1 << EN);  // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)

    LCD_COM_PORT &= ~(1 << RS); // RS = 0 (запись команд)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p << 4); // Выделяем младший нибл
    LCD_COM_PORT |= (1 << EN); // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)
    _delay_us(50);
}

// Функция записи данных в ЖКИ, выводит символы на lcd
void lcd_dat(unsigned char p)
{
    LCD_COM_PORT |= (1 << RS); // RS = 1 (запись данных)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p & 0xF0); // Выделяем старший нибл
    LCD_COM_PORT |= (1 << EN); // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)

    LCD_COM_PORT |= (1 << RS); // RS = 1 (запись данных)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p << 4); // Выделяем младший нибл
    LCD_COM_PORT |= (1 << EN); // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)
    _delay_us(50);
}

// функция вывода строки на ЖКИ
void send_string_to_LCD (const unsigned char *s)
{
    while(pgm_read_byte (s))
    {
        lcd_dat(lcd_rus(pgm_read_byte(s++)));
        _delay_ms (1);
    }
}

// Функция инициализации ЖКИ
void lcd_init(void)
{
    // Активизация четырехразрядного режима
    lcd_com(0x28); // 4 бит режим 2 строки, 5х8
    lcd_com(0x08); //выключение экрана, выключение отображения курсора, курсор не мигает 0000 1000(bin)
    lcd_com(0x06); //инкрементирование, сдвиг всего экрана отключен 0000 0110(bin)
    lcd_com(0x01); // очистка дисплея
    _delay_us(3000);// время выполнения очистки не менее 1.5ms
    lcd_com(0x0C); //включение экрана 0000 1100(bin)
    lcd_com(0x80); // Будем выводить строку в 1-ю верхнюю левую позицию 1 строки экрана
}

// Функция выделяет цифры из трехзначного числа Number, и распределяет вывод целого или плавающего заначения
void Display (unsigned int Number)
{

    short unsigned int Num1, Num2, Num3;
    Num1=Num2=0;
    while (Number >= 100)
    {
        Number -= 100;
        Num1++;
    }
    while (Number >= 10)
    {
        Number -= 10;
        Num2++;
    }
    Num3 = Number;
    lcd_com(0x88); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
    if (!temp_sign)
    {lcd_dat('+');}
    else
    {lcd_dat('-');}
    lcd_dat(Num1 + '0');
    lcd_dat(Num2 + '0');
    lcd_dat('.');
    lcd_dat(Num3 + '0');

}

// Функция инициализации датчиков
unsigned char init_device(void)
{
    unsigned char OK_Flag = 0; // переменная результата опроса присутствия датчиков
    // unsigned char Flag = 0;
    cli();
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(480);//задержка 480 мкс
    //«отпускает линию»
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(70);//задержка 70 мкс ,берем чуть больше после перепада
    if (!(OW_PIN & bit_msk)) // проверяем факт ответа датчиков, если PINB==0 - ответ есть
        OK_Flag = 1; // если ответ есть
    else
        OK_Flag = 0; // если ответа нет
    _delay_us(410);//остальная задержка 410 для окончания импульса присутствия
    sei();// разрешаем прерывания
    return OK_Flag;
}
// функция отправки 1 в линию
void send_1 (void)
{
    cli(); //Запретим общие прерывания
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(6);//задержка 15 мкс
    //«отпускает»
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(64);//задержка 45 мкс ,берем чуть больше
    sei();// разрешаем прерывания
}
// функция отправки 0 в линию
void send_0(void)
{
    cli(); //Запретим общие прерывания
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(60);//задержка 120 мкс
    //«отпускает»
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(10);//задержка 1 мкс ,перед записью следующего бита
    sei();// разрешаем прерывания
}

//Функция выдачи команд на датчики
void send_command (unsigned char command)
{
    unsigned char i;
    for (i=0; i < 8; i++)
    {
        if (command & 0x01) // если позиция бита 1, то передаем 1
        {
            send_1 ();
        }
        else //передаем 0
        {

            send_0 ();
        }
        command >>= 1;//сдвигаем вправо для обработки следующего бита
    }
}

//Функция чтения из датчиков
unsigned char read_data(void)
{
    unsigned char bit;
    cli(); //Запретим общие прерывания
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(6);//задержка 2 мкс
    //«отпускает», управление передается датчику
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(9);//задержка 9 мкс ,перед считыванием
    bit = (OW_PIN & bit_msk);
    _delay_us(55);//задержка 50 мкс ,перед чтением следующего бита
    sei();// разрешаем прерывания
    return bit;
}

//начало основой программы
int main(void)
{
    // LCD_COM_PORT_DDR |= (1<<RS)|(1<<EN); //линии RS и EN выходы, раскомм. если DAT и COM цеплять на разные порты
    // LCD_COM_PORT = 0x00; // ставим 0 в RS и EN, раскомментировать если цеплять на разные порты
    LCD_DAT_PORT_DDR = 0xFF; // порт данных (и команд в данном случае) ЖКИ - на выход
    LCD_DAT_PORT = 0x00;// ставим 0 в порт данных и команд ЖКИ
    _delay_ms(200); // Ожидание готовности ЖКИ
    lcd_init(); // Инициализация дисплея

    unsigned char j = 0;// переменные счетчики
    unsigned char i = 0;
    unsigned char n = 0;  //переменная защелка, для цикла поиска
    unsigned char data [D][8];// массив для хранения даных датчиков
    unsigned char u;//переменная для счетчика в проверочном коде
    unsigned char data_crc;// переменная, которой присваивается байт данных
    unsigned char crc8 = 0; //переменная для сравнивания кода
    unsigned char temperature[2];	// массив байтов температуры LB и HB
    unsigned char temp_int; //целая часть температура
    unsigned char temp_float; // дробная часть температуры
    unsigned int temp; // временная переменная для перевода из дополнительного кода в прямой при "-" температуре

    sei();// либо SREG |= (1 << 7); разрешить общее прерыввание
    if (n == 0) //переменная, одного входа в цикл поиска всех датчиков
    {
        unsigned char p = 1;  //переменная для цикла считыввания кода
        unsigned char bit = 0x01;// начальная позиция бита
        unsigned char New_conflict = 0; //переменная для нвой позиции бита
        unsigned char last_conflict = 0;  //переменная для старой позиции бита

        for (i = 0; i < (D); i++) //обнулим массив
        {
            for (j = 0; j < 8; j++)//8-м байт
            {
                data[i][j] = 0x00;
            }
        }
        j = 0;//обнуляем
        i = 0;//обнуляем
        unsigned char bit1, bit2; //для сравнения битов двух тайм слотов

        do
        {
            New_conflict = 0;
            n++;
            if (!init_device())	// выдаём импульс сброса и проверяем ответ датчиков
            {
                // если ф-ция сброса вернёт 0
                lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
                send_string_to_LCD (absence);//выводим "нет датчиков"
                abort ();
            }
            send_command(0xF0); // команда поиска
            // сигнал сброса и команду поиска необходимо подавать для каждого датчика

            while (p <= 64) // пока не будут прочитаны все 64 бита
            {
                bit1 = read_data();//первый тайм-слот
                // _delay_us(2); // без этой задержки иногда не работает
                bit2 = read_data();//второй тайм-слот
                if (bit1 && bit2) // сравниваем полученные биты , если обе единицы
                {
                    lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
                    send_string_to_LCD (no_answer);//выводим "нет ответа датч."
                    abort ();
                }
                else if ((bit1) && (!bit2))// бит = 1
                    data[i][j] |= bit;//записываем бит
                else if((!bit1) && (bit2))// бит = 0
                    data[i][j] &= ~bit;
                else if((!bit1) && (!bit2))//Конфликт оба 0
                {
                    //здесь будем сравнивать позиции битов,  в номерах которых произошли конфликты  в переменной N_conflict
                    if (p == last_conflict)//если текущая позиция бита в котром произошел конфликт ==  позиции в предыдущем исчеслении (скорей всего 0-ая позиция), то запишем в адресс 1
                        data[i][j] |= bit;
                    else if (p > last_conflict)// если номер позиции больше, номера предыдущего опроса, то запишем 0 и номер позиции конфликта обновим
                    {
                        data[i][j] &= ~bit;
                        New_conflict = p;
                    }
                        //если вдруг текущий номер позиции меньше, номера позиции предыдущего исчесления(Если вдруг текущий бит, при конфликте, при очередном исчеслении не дошел еще до номера
                        //конфликта предыдущего исчесления,  содержит 0 , то это будет считаться новым конфликтом)
                    else if (!(data[i-1][j] & bit))
                    {
                        New_conflict = p;
                        data[i][j] &= ~bit;
                    }
                    else
                    {data[i][j] |= bit;}
                }

                // Далее запишем соответствующий бит, который при следующем исчеслении включит соответствующие устройства
                if(data[i][j] & bit)
                {
                    send_1 ();
                }
                else //передаем 0
                {
                    send_0 ();
                }

                p++;//увеличиваем на 1
                bit <<= 1;//сдвигаем влево

                if (!bit) //сдвиг проходит все 8 бит и значение равно 0
                {
                    j++;
                    _delay_ms(100);
                    bit = 0x01;
                }

            }//выходит из цикла после обработки 64-х битов
            last_conflict = New_conflict;
            p = 1;
            if (last_conflict != 0)
            {
                i++;
                j = 0;
                bit = 0x01;
            }
        }

        while (last_conflict != 0); // пока номер бита конфликта не равен 0, если равен то все датчики найдены

        lcd_com(0x01); // очистка дисплея
        _delay_us(1500);// время выполнения очистки не менее 1.5ms
        lcd_com(0x80);
        //send_string_to_LCD ((uint8_t *)strcpy_P(buffer, (PGM_P) present_n)); // Выводим "Подкл.дат."
        send_string_to_LCD (present_n); // Выводим "Подкл.дат."
        lcd_dat(n +'0');// выводим количество найденых датчиков (значение переменной n из цикла поиска)
        _delay_ms(4000);
    }

    //Датчики найдены, адреса занисаны, необходимо проверить правильность переданной информации
    i = 0;//обнулим, начнем проверрку с 0-х индексов
    j = 0;
    while(i != n)//обрабатываем количество устройств(равно n из цикла поиска), начинаем с первого устройства
    {
        crc8 = 0;
        for(j = 0; j < 7; j++)
        {
            unsigned char bit_crc; //локальная переменная
            data_crc = data[i][j];
            for (u = 0 ; u < 8; u++)
            {
                bit_crc = ((crc8 ^ data_crc) & 0x01);
                if (bit_crc == 0)
                    crc8 >>= 1;
                else
                {
                    crc8 ^= 0x18;//  11000 , по модулю т.е. там где0 и 1 будут 1
                    crc8 >>= 1; //сдвгаем влево
                    crc8 |= 0x80;//+ 1000 0000
                }
                data_crc >>=1;
            }
        }
        if (crc8 == data[i][j]) // если последний байт четности равны то хорошо
            i++;
        else
        {
            lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
            send_string_to_LCD (error);//выводим "ошибка иниц."
            lcd_dat((i+1)+'0');// выводим № датчика с ошибкой в ID
            abort ();
        }
    }

    lcd_com(0x01); // очистка дисплея
    _delay_us(1500);// время выполнения очистки не менее 1.5ms
    lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
    send_string_to_LCD (init_n); //выводим "Иниц.дат."
    lcd_dat(i+'0');
    _delay_ms(4000);
    lcd_com(0x01); // очистка дисплея
    _delay_us(1500);// время выполнения очистки не менее 1.5ms
    lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
    send_string_to_LCD (tempC); //выводим "Темп-ра "

    while(1)
    {
        for (i = 0; i< n; i++) //начинаем с первого датчика
        {
            init_device();//импульс сброса и присутствие
            send_command(0x55);//комманда соответствия
            // после передадим код устройства к которому обращаемся

            for (j = 0; j < 8 ; j++)
            {
                unsigned char data_byte; // переменная для передачи кода
                data_byte = data[i][j];
                send_command (data_byte); //передаем побайтово код устройства
            }

            send_command (0x44);//комманда преобразования
            while (!read_data()) ;// выполняется цикл пока на линии не установится 1 - преобразование закончено
            init_device();//импульс сброса и присутствие
            send_command(0x55);//комманда соответствия
            for (j = 0; j < 8 ; j++)   // опять передаем адресс устройствак которому будем обращаться
            {
                unsigned char data_byte; // переменная для передачи кода
                data_byte = data[i][j];
                send_command (data_byte); //передаем побайтово код устройства
            }
            send_command (0xBE);//комманда чтение памяти
            for (j = 0; j < 2; j++) //считываем первые два байта температуры
            {
                unsigned char i;//локальная переменная для внутреннего цикла
                unsigned char data_temp = 0x00;
                for (i = 0; i < 8; i++)
                {
                    data_temp >>= 1;
                    if (read_data()) //если 1, то устанавливаем  старший бит 1
                        data_temp |= 0x80;
                }
                temperature[j] = data_temp;
            }
            init_device();	// сброс датчиков для прекращения передачи данных

            /*
            //проверяем целостность информации измеренной температуры
            crc8 = 0;
            for(j = 0; j < 7; j++)
            {
                unsigned char bit_crc; //локальная переменная
                data_crc = temperature[j];
                for (u = 0 ; u < 8; u++)
                {
                    bit_crc = ((crc8 ^ data_crc) & 0x01);
                    if (bit_crc == 0)
                        crc8 >>= 1;
                    else
                    {
                        crc8 ^= 0x18;//  11000 , по модулю т.е. там где0 и 1 будут 1
                        crc8 >>= 1; //сдвгаем влево
                        crc8 |= 0x80;//+ 1000 0000
                    }
                    data_crc >>=1;
                }
            }
            if (crc8 == temperature[j]) // если последний байт четности равныто хорошо
            {


            }
            else
            {
                Display(000);
                _delay_ms(1000);
            }
            */
            //
            if ((temperature[1]&0b10000000) == 0)
                temp_sign =0; //рисуем плюс на ЖКИ
            else //переводим из доп.кода в прямой
            {
                temp = ((unsigned int)temperature[1]<<8) | temperature[0];
                temp = ~temp + 1;
                temperature[0] = temp;
                temperature[1] = temp>>8;
                temp_sign = 1;  //рисуем минус на ЖКИ
            }

            temp_int = ((temperature[1]&0b00000111)<<4)|(temperature[0]>>4);	//выводим  целое знач. температуры
            temp_float = (temperature[0]&0b00001111); //выделяем с помощью битовой маски дробную часть
            /*
			преобразуем в целое число и *10 (нужен только 1 десятичный знак),
			десятичную "." будем ставить принудительно
			1. temp_float = temp_float * 0.0625 -  просто умножаем на 0.0625 или
				 (temp_float >> 4)  - делим на 16 сдвигами
			2. (temp_float + temp_int)*10 - просто умножаем на 10 или
				((((temp_float + temp_int)<<1) + (temp_float + temp_int)<<3)) - умножаем на 10 сдвигами
			*/

            Display(((uint8_t)(temp_float*0.0625) + temp_int)*10);	// Явно приводим к uint8_t, чтобы уйти от float
            _delay_ms(2000);
            temp_int = 0;
            temp_float = 0;
        }
    }	// закрывающая скобка бесконечного цикла
}      // закрывающая скобка основной программы
