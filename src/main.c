#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h> //для sei() и cli()
#include <stdlib.h> // для abort()
#include <avr/pgmspace.h> //раскомментировать, если хранить строки и массив во флэш
#include <avr/eeprom.h> //для работы с еепром
#include <string.h> //для strncpy
// #include <math.h> раскомментировать, если нужна ф-я modf в ф-ии преобразования ЧПТ в цифры для передачи в ЖКИ

//блок define для LCD
#define RS PORTD3 //  Номер вывода порта, по которому передаётся команда RS в ЖКИ
#define EN PORTD2 //  Номер вывода порта, по которому передаётся команда EN в ЖКИ
#define LCD_COM_PORT PORTD // Порт для посыла команд в ЖКИ (команды и данные - могут быть не на одном порту!!!)
//#define LCD_COM_PORT_DDR DDRD // Регистр направления данных в порту, куда подцеплены линии команд ЖКИ, см.выше
#define LCD_DAT_PORT PORTD // Порт отправки данных (и команд в данном случае)в ЖКИ
#define LCD_DAT_PORT_DDR DDRD // Регистр направления данных порта, куда подцеплен ЖКИ линиями данных (и команд в данном случае)
/* бит-маски выделения ниблов и отправки их в порт LCD_DAT_PORT составляются соответственно номеров выводов, к которым
подключен ЖКИ. в данном случае используются выводы 4-7 порта. */

//блок define для OW
#define DDR_OW_PORT DDRB // Регистр направления данных порта, к одному из выводов которого подключена линия 1-Wire
#define OW_PORT PORTB // Порт, к одному из выводов которого подключена линия 1-Wire
#define OW_PIN PINB // Регистр приёма ответа линии 1-Wire, к одному из выводов которого подключена эта линия
#define OW_PIN_NUM 0 // Номер PIN, к которому подключена линия 1-Wire, для макроса _BV()
#define bit_msk 0x01 // Битовая маска для проверки сигнала от линии 1-Wire на соответствующем пине

//блок define для кнопки
#define SRC_PORT PORTB //Порт, к одному из выводов которого подключена кнопка нового поиска (здесь порт один с OW line)
#define DDR_SRC_PORT DDRB // Регистр направления данных порта, к одному из выводов которого подключена кнопка нового поиска (здесь порт один с OW line)
#define SRC_PIN PINB // Регистр приёма состояния кнопки
#define SRC_PIN_NUM 1 // Номер PIN, к которому подключена кнопка, для макроса _BV()
#define src_msk 0x02 // Битовая маска для проверки сигнала от линии 1-Wire на соответствующем пине

//unsigned char tempC[] PROGMEM = "Темп-ра ";
unsigned char absence[] PROGMEM = "Нет датчиков";
unsigned char error[] PROGMEM = "ошибка иниц.";
unsigned char present_n[] PROGMEM = "Подкл.дат. ";
unsigned char init_n[] PROGMEM = "Иниц.дат. ";
unsigned char no_answer[] PROGMEM = "Нет ответа датч. ";
unsigned char temp_sign; // признак знака температуры для ф-ции вывода на ЖКИ


typedef struct
{
    unsigned char name[8]; // имя 1W устройства
    unsigned char code[8]; // код 1W устройства
    char tmax; // максимальная Т
    char tmin; // минимальная Т
} device; // структура для параметров 1W устройства

device buffer; // переменная для обмена озу <-> епром
device ee_arr [2] EEMEM; // oбъявляем массив структур в епром, 2 - пока временно, для начала
unsigned char *location; //переменная для имени 1W устройств - задаётся юзером вместо имени по умолчанию
unsigned char dev_num = 0x00; //переменная порядкового номера для добавления к имени 1W устройств по умолчанию,
unsigned char dev_name[8] = {'D', 'x', 'x', 'x', 'x', 'x', 'x', 'x'}; //"D__" - имя устройства по умолчанию, к нему добавится ASCII код порядкового номера
//unsigned char dev_qty EEMEM;
const uint16_t dev_qty = 0x3FF;//константа, содержащая значение адреса последней ячейки в епром для переменной количества найденных устройств


// Функция записи команды в ЖКИ
void lcd_com(unsigned char p)
{
    LCD_COM_PORT &= ~(1 << RS); // RS = 0 (запись команд)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p & 0xF0); // Выделяем старший нибл
    LCD_COM_PORT |= (1 << EN);  // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)

    LCD_COM_PORT &= ~(1 << RS); // RS = 0 (запись команд)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p << 4); // Выделяем младший нибл
    LCD_COM_PORT |= (1 << EN); // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)
    _delay_us(50);
}

// Функция записи данных в ЖКИ, выводит символы на lcd
void lcd_dat(unsigned char p)
{
    LCD_COM_PORT |= (1 << RS); // RS = 1 (запись данных)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p & 0xF0); // Выделяем старший нибл
    LCD_COM_PORT |= (1 << EN); // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)

    LCD_COM_PORT |= (1 << RS); // RS = 1 (запись данных)
    LCD_DAT_PORT &= 0x0F; LCD_DAT_PORT |= (p << 4); // Выделяем младший нибл
    LCD_COM_PORT |= (1 << EN); // EN = 1 (начало записи команды в LCD)
    _delay_us(2);
    LCD_COM_PORT &= ~(1 << EN); // EN = 0 (конец записи команды в LCD)
    _delay_us(50);
}

//Таблица перекодировки в русские символы.
static const unsigned char convert_HD44780[64]PROGMEM =
        {
                0x41,0xA0,0x42,0xA1,0xE0,0x45,0xA3,0xA4,
                0xA5,0xA6,0x4B,0xA7,0x4D,0x48,0x4F,0xA8,
                0x50,0x43,0x54,0xA9,0xAA,0x58,0xE1,0xAB,
                0xAC,0xE2,0xAD,0xAE,0xAD,0xAF,0xB0,0xB1,
                0x61,0xB2,0xB3,0xB4,0xE3,0x65,0xB6,0xB7,
                0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0x6F,0xBE,
                0x70,0x63,0xBF,0x79,0xE4,0x78,0xE5,0xC0,
                0xC1,0xE6,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7
        };

// функция перекодировки символов
static unsigned char lcd_rus(uint8_t c)
{
    if  (c > 191)
    {
        c -= 192;
        c = pgm_read_byte (&(convert_HD44780[c]));
    }
    return c;
}

// функция вывода строки на ЖКИ
void send_string_to_LCD (const unsigned char *s)
{
    while(pgm_read_byte (s))
    {
        lcd_dat(lcd_rus(pgm_read_byte(s++)));
        _delay_ms (1);
    }
}

// функция вывода массива символов на ЖКИ (в массиве должен быть символ "конца строки" 0x00)
void send_arr_to_LCD (unsigned char *s)
{
    while(*s)
    {
        lcd_dat(lcd_rus (*s++));
        _delay_ms (1);
    }
}

// Функция инициализации ЖКИ
void lcd_init(void)
{
    // Активизация четырехразрядного режима
    lcd_com(0x28); // 4 бит режим 2 строки, 5х8
    lcd_com(0x08); //выключение экрана, выключение отображения курсора, курсор не мигает 0000 1000(bin)
    lcd_com(0x06); //инкрементирование, сдвиг всего экрана отключен 0000 0110(bin)
    lcd_com(0x01); // очистка дисплея
    _delay_us(3000);// время выполнения очистки не менее 1.5ms
    lcd_com(0x0C); //включение экрана 0000 1100(bin)
    //lcd_com(0x80); // Будем выводить строку в 1-ю верхнюю левую позицию 1 строки экрана
}

// Функция выделяет цифры из трехзначного числа Number, и распределяет вывод целого или плавающего заначения
void Display (unsigned int Number, uint8_t i)
{

    short unsigned int Num1, Num2, Num3;
    Num1=Num2=0;
    while (Number >= 100)
    {
        Number -= 100;
        Num1++;
    }
    while (Number >= 10)
    {
        Number -= 10;
        Num2++;
    }
    Num3 = Number;
    i &= 0x01; //определяем строку вывода на дисплей: № устр-в 0,2,4... верхняя, 1,3,5... нижняя
    if (!i) //если строка верхняя - чистим дисплей
    {
        lcd_com(0x01); // очистка дисплея
        _delay_us(1500);// время выполнения очистки не менее 1.5ms
    }
    lcd_com(0x80 + (i*0x40)); // выводим строку в 1-ю верхнюю левую позицию 1 или 2 строки экрана
    send_arr_to_LCD (buffer.name); //выводим имя устройства
    lcd_com(0x88 + (i*0x40)); // выводим температуру в 8-ю (от 0) позицию 1ю или 2ю строки экрана
    if (!temp_sign)
    {lcd_dat('+');}
    else
    {lcd_dat('-');}
    lcd_dat(Num1 + '0');
    lcd_dat(Num2 + '0');
    lcd_dat('.');
    lcd_dat(Num3 + '0');

}

// Функция инициализации датчиков
unsigned char init_device(void)
{
    unsigned char OK_Flag = 0; // переменная результата опроса присутствия датчиков
    // unsigned char Flag = 0;
    cli();
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(480);//задержка 480 мкс
    //«отпускает линию»
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(70);//задержка 70 мкс ,берем чуть больше после перепада
    if (!(OW_PIN & bit_msk)) // проверяем факт ответа датчиков, если PINB==0 - ответ есть
        OK_Flag = 1; // если ответ есть
    else
        OK_Flag = 0; // если ответа нет
    _delay_us(410);//остальная задержка 410 для окончания импульса присутствия
    sei();// разрешаем прерывания
    return OK_Flag;
}
// функция отправки 1 в линию
void send_1 (void)
{
    cli(); //Запретим общие прерывания
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(6);//задержка 15 мкс
    //«отпускает»
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(64);//задержка 45 мкс ,берем чуть больше
    sei();// разрешаем прерывания
}
// функция отправки 0 в линию
void send_0(void)
{
    cli(); //Запретим общие прерывания
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(60);//задержка 120 мкс
    //«отпускает»
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(10);//задержка 1 мкс ,перед записью следующего бита
    sei();// разрешаем прерывания
}

//Функция выдачи команд на датчики
void send_command (unsigned char command)
{
    unsigned char i;
    for (i=0; i < 8; i++)
    {
        if (command & 0x01) // если позиция бита 1, то передаем 1
        {
            send_1 ();
        }
        else //передаем 0
        {

            send_0 ();
        }
        command >>= 1;//сдвигаем вправо для обработки следующего бита
    }
}

//Функция чтения из датчиков
unsigned char read_data(void)
{
    unsigned char bit;
    cli(); //Запретим общие прерывания
    OW_PORT &= ~_BV(OW_PIN_NUM);//в порту ставим 0
    DDR_OW_PORT |= _BV(OW_PIN_NUM);//1 - порт на выход
    _delay_us(6);//задержка 2 мкс
    //«отпускает», управление передается датчику
    DDR_OW_PORT &= ~_BV(OW_PIN_NUM);//0 - порт на вход
    _delay_us(9);//задержка 9 мкс ,перед считыванием
    bit = (OW_PIN & bit_msk);
    _delay_us(55);//задержка 50 мкс ,перед чтением следующего бита
    sei();// разрешаем прерывания
    return bit;
}
// Функция поиска устройств, запись в еепром, проверка CRC кодов найденных устройств
void search_ID(void)
{


    unsigned char i, j = 0;// переменные счетчики
    unsigned char n = 0;  //количество датчиков, записанных в епром
    unsigned char data [8];// буфер-массив для хранения кодов датчиков
    unsigned char u;//переменная для счетчика в блоке проверки CRC8
    unsigned char data_crc;// переменная, которой присваивается байт данных в блоке проверки CRC8
    unsigned char crc8 = 0; //переменная для вычисления CRC8 в блоке проверки CRC8

    sei();// либо SREG |= (1 << 7); разрешить общее прерыввание
    if (n == 0) //переменная, одного входа в цикл поиска всех датчиков
    {
        unsigned char p = 1;  //переменная для цикла считыввания кода
        unsigned char bit = 0x01;// начальная позиция бита
        unsigned char New_conflict = 0; //переменная для нвой позиции бита
        unsigned char last_conflict = 0;  //переменная для старой позиции бита

        for (j = 0; j < 8; j++) //обнулим буфер-массив
        {
            data[j] = 0x00;
        }
        j = 0;//обнуляем счётчик буфер-массива
        unsigned char bit1, bit2; //для сравнения битов двух тайм слотов

        do
        {
            New_conflict = 0;
            n++;
            if (!init_device())	// выдаём импульс сброса и проверяем ответ датчиков
            {
                // если ф-ция сброса вернёт 0
                lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
                send_string_to_LCD (absence);//выводим "нет датчиков"
                abort ();
            }
            send_command(0xF0); // команда поиска
            // сигнал сброса и команду поиска необходимо подавать для каждого датчика

            while (p <= 64) // пока не будут прочитаны все 64 бита
            {
                bit1 = read_data();//первый тайм-слот
                // _delay_us(2); // без этой задержки иногда не работает
                bit2 = read_data();//второй тайм-слот
                if (bit1 && bit2) // сравниваем полученные биты , если обе единицы
                {
                    lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
                    send_string_to_LCD (no_answer);//выводим "нет ответа датч."
                    abort ();
                }
                else if ((bit1) && (!bit2))// бит = 1
                    data[j] |= bit;//записываем бит
                else if((!bit1) && (bit2))// бит = 0
                    data[j] &= ~bit;
                else if((!bit1) && (!bit2))//Конфликт оба 0
                {
                    //здесь будем сравнивать позиции битов,  в номерах которых произошли конфликты  в переменной N_conflict
                    if (p == last_conflict)//если текущая позиция бита в котром произошел конфликт ==  позиции в предыдущем исчеслении (скорей всего 0-ая позиция), то запишем в адресс 1
                        data[j] |= bit;
                    else if (p > last_conflict)// если номер позиции больше, номера предыдущего опроса, то запишем 0 и номер позиции конфликта обновим
                    {
                        data[j] &= ~bit;
                        New_conflict = p;
                    }
                        //если вдруг текущий номер позиции меньше, номера позиции предыдущего исчесления(Если вдруг текущий бит, при конфликте, при очередном исчеслении не дошел еще до номера
                        //конфликта предыдущего исчесления,  содержит 0 , то это будет считаться новым конфликтом)
                    else if (!(data[j] & bit))
                    {
                        New_conflict = p;
                        data[j] &= ~bit;
                    }
                    else
                    {data[j] |= bit;}
                }

                // Далее запишем соответствующий бит, который при следующем исчеслении включит соответствующие устройства
                if(data[j] & bit)
                {
                    send_1 ();
                }
                else //передаем 0
                {
                    send_0 ();
                }

                p++;//увеличиваем на 1
                bit <<= 1;//сдвигаем влево

                if (!bit) //сдвиг проходит все 8 бит и значение равно 0
                {
                    j++;
                    _delay_ms(100);
                    bit = 0x01;
                }

            }//выходит из цикла после обработки 64-х битов
            last_conflict = New_conflict;
            p = 1;

            location = dev_name;//временно локации устройства присваивается ASCII код имени по умолчанию
            utoa (dev_num, (void*)&dev_name[3], 10);// в имя по умолчанию добавляется ASCII код номера устройства по порядку поиска
            //приходится использовать явное приведение к void*, т.к. utoa и strncpy не жрут ничего, кроме char*, а у нас unsigned char*
            strncpy((void*)buffer.name, (void*)location, sizeof buffer.name); // записываем ASCII код имени в поле name буфера

            // запись ID-кода 1-го 1W устройства в ID_string и копирование его в буфер-структуру
            for (j=0; j < 8; j++)
            {
                buffer.code[j] = data[j];
            }
            /* заполняем поля tmax и tmin буфера значениями */
            buffer.tmax = 30;
            buffer.tmin = 6;
            eeprom_update_block (&buffer, &ee_arr[dev_num], sizeof(buffer)); // записываем в епром описание текущего 1W устройства.
            dev_num ++; //инкременируем номер устройства - это будет следующее

            if (last_conflict != 0)
            {
                j = 0;
                bit = 0x01;
            }
        }

        while (last_conflict != 0); // пока номер бита конфликта не равен 0, если равен то все датчики найдены

        lcd_com(0x01); // очистка дисплея
        _delay_us(1500);// время выполнения очистки не менее 1.5ms
        lcd_com(0x80);
        //send_string_to_LCD ((uint8_t *)strcpy_P(buffer, (PGM_P) present_n)); // Выводим "Подкл.дат."
        send_string_to_LCD (present_n); // Выводим "Подкл.дат."
        lcd_dat(n +'0');// выводим количество найденых датчиков (значение переменной n из цикла поиска)
        _delay_ms(3000);
    }

    //Датчики найдены, адреса записаны, необходимо проверить правильность переданной информации
    i = 0;//обнулим, начнем проверрку с 0-х индексов
    j = 0;
    while(i != n)//обрабатываем количество устройств(равно n из цикла поиска), начинаем с первого устройства
    {
        eeprom_read_block (&buffer, &ee_arr[i], sizeof(buffer));// считываем описание усройства их епром
        crc8 = 0;
        for(j = 0; j < 7; j++)
        {
            unsigned char bit_crc; //локальная переменная
            data_crc = buffer.code[j];
            for (u = 0 ; u < 8; u++)
            {
                bit_crc = ((crc8 ^ data_crc) & 0x01);
                if (bit_crc == 0)
                    crc8 >>= 1;
                else
                {
                    crc8 ^= 0x18;//  11000 , по модулю т.е. там где0 и 1 будут 1
                    crc8 >>= 1; //сдвгаем влево
                    crc8 |= 0x80;//+ 1000 0000
                }
                data_crc >>=1;
            }
        }
        if (crc8 == buffer.code[j]) // если последний байт четности равны то хорошо
            i++;
        else
        {
            lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
            send_string_to_LCD (error);//выводим "ошибка иниц."
            lcd_dat((i+1)+'0');// выводим № датчика с ошибкой в ID
            abort ();
        }
    }

    lcd_com(0x01); // очистка дисплея
    _delay_us(1500);// время выполнения очистки не менее 1.5ms
    lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
    send_string_to_LCD (init_n); //выводим "Иниц.дат."
    lcd_dat(i+'0');//выводим кол-во устр-в, прошедших проверку CRC8
    _delay_ms(3000);
    lcd_com(0x01); // очистка дисплея
    _delay_us(1500);// время выполнения очистки не менее 1.5ms
    //lcd_com(0x80); // выводим строку в 1-ю верхнюю левую позицию 1 строки экрана
    //send_string_to_LCD (tempC); //выводим "Темп-ра "
    //eeprom_update_byte (&dev_qty, n);0x0400
    eeprom_update_byte ((uint8_t*)dev_qty, n);
}


//начало основой программы
int main(void)
{
    unsigned char temperature[2];	// массив байтов температуры LB и HB
    unsigned char temp_int; //целая часть температура
    unsigned char temp_float; // дробная часть температуры
    unsigned int temp; // временная переменная для перевода из дополнительного кода в прямой при "-" температуре

    // LCD_COM_PORT_DDR |= (1<<RS)|(1<<EN); //линии RS и EN выходы, раскомм. если DAT и COM цеплять на разные порты
    // LCD_COM_PORT = 0x00; // ставим 0 в RS и EN, раскомментировать если цеплять на разные порты
    LCD_DAT_PORT_DDR = 0xFF; // порт данных (и команд в данном случае) ЖКИ - на выход
    LCD_DAT_PORT = 0x00;// ставим 0 в порт данных и команд ЖКИ
    _delay_ms(200); // Ожидание готовности ЖКИ
    lcd_init(); // Инициализация дисплея

    DDR_SRC_PORT &= ~_BV(SRC_PIN_NUM);//ставим 0 - пин кнопки активирован на вход
    SRC_PORT |= _BV(SRC_PIN_NUM);//ставим 1 - внутр. подтяжка к +
    if (!(SRC_PIN & src_msk)) //если на пине 0, кнопка нажата
    {
        search_ID();
    }

    while(1)
    {
        unsigned char j = 0;// переменные счетчики
        unsigned char i = 0;
        unsigned char n = 0;
        //n = eeprom_read_byte(&dev_qty);
        n = eeprom_read_byte((uint8_t*)dev_qty);


        for (i = 0; i< n; i++) //начинаем с первого датчика (от 0)
        {
            eeprom_read_block (&buffer, &ee_arr[i], sizeof(buffer)); // считываем описание усройства их епром
            init_device();//импульс сброса и присутствие
            send_command(0x55);//команда соответствия
            // после передадим код устройства к которому обращаемся
            for (j = 0; j < 8 ; j++)
            {
                unsigned char data_byte; // переменная для передачи кода
                data_byte = buffer.code[j];
                send_command (data_byte); //передаем побайтово код устройства
            }

            send_command (0x44);//команда преобразования
            while (!read_data()) ;// выполняется цикл пока на линии не установится 1 - преобразование закончено
            init_device();//импульс сброса и присутствие
            send_command(0x55);//команда соответствия
            for (j = 0; j < 8 ; j++)   // опять передаем адресс устройства, к которому будем обращаться
            {
                unsigned char data_byte; // переменная для передачи кода
                data_byte = buffer.code[j];
                send_command (data_byte); //передаем побайтово код устройства
            }
            send_command (0xBE);//команда чтение памяти
            for (j = 0; j < 2; j++) //считываем первые два байта температуры
            {
                unsigned char i;//локальная переменная для внутреннего цикла
                unsigned char data_temp = 0x00;
                for (i = 0; i < 8; i++)
                {
                    data_temp >>= 1;
                    if (read_data()) //если 1, то устанавливаем  старший бит 1
                        data_temp |= 0x80;
                }
                temperature[j] = data_temp;
            }
            init_device();	// сброс датчиков для прекращения передачи данных

            /*
            //проверяем целостность информации измеренной температуры
            crc8 = 0;
            for(j = 0; j < 7; j++)
            {
                unsigned char bit_crc; //локальная переменная
                data_crc = temperature[j];
                for (u = 0 ; u < 8; u++)
                {
                    bit_crc = ((crc8 ^ data_crc) & 0x01);
                    if (bit_crc == 0)
                        crc8 >>= 1;
                    else
                    {
                        crc8 ^= 0x18;//  11000 , по модулю т.е. там где0 и 1 будут 1
                        crc8 >>= 1; //сдвгаем влево
                        crc8 |= 0x80;//+ 1000 0000
                    }
                    data_crc >>=1;
                }
            }
            if (crc8 == temperature[j]) // если последний байт четности равныто хорошо
            {


            }
            else
            {
                Display(000);
                _delay_ms(1000);
            }
            */
            //
            if ((temperature[1]&0b10000000) == 0)
                temp_sign =0; //рисуем плюс на ЖКИ
            else //переводим из доп.кода в прямой
            {
                temp = ((unsigned int)temperature[1]<<8) | temperature[0];
                temp = ~temp + 1;
                temperature[0] = temp;
                temperature[1] = temp>>8;
                temp_sign = 1;  //рисуем минус на ЖКИ
            }

            temp_int = ((temperature[1]&0b00000111)<<4)|(temperature[0]>>4);	//выводим  целое знач. температуры
            temp_float = (temperature[0]&0b00001111); //выделяем с помощью битовой маски дробную часть
            /*
            преобразуем в целое число и *10 (нужен только 1 десятичный знак),
            десятичную "." будем ставить принудительно
            1. temp_float = temp_float * 0.0625 -  просто умножаем на 0.0625 или
                 (temp_float >> 4)  - делим на 16 сдвигами
            2. (temp_float + temp_int)*10 - просто умножаем на 10 или
                ((((temp_float + temp_int)<<1) + (temp_float + temp_int)<<3)) - умножаем на 10 сдвигами
            */

            Display ((((uint8_t)(temp_float*0.0625) + temp_int)*10), i); //Явно приводим к uint8_t, чтобы уйти от float; передаём № устр-ва для определ. строки дисп.
            if ((i & 0x01)||(i == (n-1))) //определяем строку вывода на дисплей: № устр-в 0,2,4... верхняя, 1,3,5... нижняя;
                //если строка нижняя - ставим задержку перед сменой экрана.
                //Если строка верхняя, но устройство последнее - тоже задержка
            {
                _delay_ms(2000);
            }
            temp_int = 0;
            temp_float = 0;
        }
    }	// закрывающая скобка бесконечного цикла
}      // закрывающая скобка основной программы
